{"file_contents":{"README.md":{"content":"# VisionFit AI - Nutritional Guidance System\n\n## Overview\n\nVisionFit AI is a comprehensive nutrition application that combines artificial intelligence with image analysis to provide personalized nutritional guidance. The system uses Google's Gemini AI for intelligent meal planning and nutritional analysis.\n\n## Features\n\n- **Food Analysis**: Image-based nutritional analysis of meals\n\n## Supported Exercises\n\nThe real-time workout analysis system currently supports the following exercises:\n\n- **Push-ups**: Tracks elbow angle and body alignment\n- **Squats**: Monitors knee angle and alignment\n- **Jumping Jacks**: Analyzes arm and leg spread\n\n## Installation\n\n1. Clone the repository\n2. Create a virtual environment: `python -m venv .venv`\n3. Activate the virtual environment:\n   - Windows: `.venv\\Scripts\\activate`\n   - macOS/Linux: `source .venv/bin/activate`\n4. Install dependencies: `pip install -r requirements.txt`\n5. Run the application: `python VisionFitAI/app.py`\n\n## Usage\n\n1. Navigate to the Workout Analysis page\n2. Select the exercise you want to perform\n3. Take a photo of your meal\n4. Get instant nutritional analysis and recommendations\n\n## Technical Details\n\n- **Backend**: Flask web framework with SQLAlchemy ORM\n- **Computer Vision**: MediaPipe Pose solution for real-time body landmark detection\n- **Exercise Recognition**: Custom algorithms for exercise detection and form analysis\n- **Frontend**: HTML/CSS/JavaScript with Bootstrap 5\n\n## Requirements\n\n- Python 3.11+\n- Webcam\n- Modern web browser with JavaScript enabled\n- Dependencies listed in requirements.txt\n\n## License\n\nMIT License","size_bytes":1611},"app.py":{"content":"import os\nimport logging\n\nfrom flask import Flask\nfrom werkzeug.middleware.proxy_fix import ProxyFix\n\n# Import extensions\nfrom extensions import db, login_manager\n\n# Configure logging\nlogging.basicConfig(level=logging.DEBUG)\n\ndef create_app():\n    # Create the app\n    app = Flask(__name__)\n    app.secret_key = os.environ.get(\"SESSION_SECRET\", \"dev-secret-key-change-in-production\")\n    app.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)\n\n    # Configure the database\n    app.config[\"SQLALCHEMY_DATABASE_URI\"] = os.environ.get(\"DATABASE_URL\", \"sqlite:///visionfit.db\")\n    app.config[\"SQLALCHEMY_ENGINE_OPTIONS\"] = {\n        \"pool_recycle\": 300,\n        \"pool_pre_ping\": True,\n    }\n\n    # Initialize extensions\n    db.init_app(app)\n    login_manager.init_app(app)\n    login_manager.login_view = 'login'\n\n    @login_manager.user_loader\n    def load_user(user_id):\n        from models import User\n        return User.query.get(int(user_id))\n\n    with app.app_context():\n        # Import models first\n        import models\n\n        # Create all tables\n        db.create_all()\n\n    return app\n\n# Create the app instance\napp = create_app()\n\n# Import and register routes after app creation\n# We need to import routes here to avoid circular imports\nimport routes\n\n# Register all routes with the Flask app instance\nroutes.register_routes(app)\n\nif __name__ == '__main__':\n    app.run(host='127.0.0.1', port=5000, debug=True)\n","size_bytes":1426},"extensions.py":{"content":"from flask_sqlalchemy import SQLAlchemy\nfrom flask_login import LoginManager\nfrom sqlalchemy.orm import DeclarativeBase\n\nclass Base(DeclarativeBase):\n    pass\n\ndb = SQLAlchemy(model_class=Base)\nlogin_manager = LoginManager()\n","size_bytes":225},"gemini.py":{"content":"\nimport json\nimport logging\nimport os\nimport base64\nimport re\nfrom typing import Dict, Any\n\ntry:\n    import google.generativeai as genai\n    GENAI_AVAILABLE = True\nexcept ImportError:\n    GENAI_AVAILABLE = False\n    logging.warning(\"Google GenerativeAI not available. Using mock responses.\")\n\nfrom pydantic import BaseModel\n\nclass WorkoutPlan(BaseModel):\n    plan_name: str\n    duration_weeks: int\n    workouts: list\n\nclass FoodAnalysis(BaseModel):\n    food_items: list\n    total_calories: int\n    nutritional_info: dict\n\n# Initialize Gemini AI client\nif GENAI_AVAILABLE:\n    try:\n        # Use the provided API key directly\n        api_key = \"AIzaSyAGDJZktWCgc-78xHrCp7g4a-nFLyPW6Bw\"\n        genai.configure(api_key=api_key)\n        model = genai.GenerativeModel('gemini-1.5-flash')\n        GEMINI_CONFIGURED = True\n        logging.info(\"Gemini AI configured successfully with API key\")\n    except Exception as e:\n        GEMINI_CONFIGURED = False\n        logging.error(f\"Failed to configure Gemini AI: {e}\")\nelse:\n    GEMINI_CONFIGURED = False\n\ndef generate_workout_plan(fitness_level: str, goals: str, equipment: str = \"none\") -> Dict[str, Any]:\n    \"\"\"Generate a personalized workout plan using Gemini AI\"\"\"\n    try:\n        if GEMINI_CONFIGURED:\n            prompt = f\"\"\"\n            Create a personalized workout plan for someone with:\n            - Fitness Level: {fitness_level}\n            - Goals: {goals}\n            - Available Equipment: {equipment}\n\n            Generate a detailed 4-week workout plan including:\n            - Weekly workout schedule (3-5 days per week)\n            - Specific exercises with sets/reps\n            - Progressive difficulty increase each week\n            - Rest days and recovery advice\n\n            Format the response as a structured workout plan with clear sections for each week.\n            Make it practical and achievable for the specified fitness level.\n            \"\"\"\n\n            response = model.generate_content(prompt)\n            return {\"success\": True, \"plan\": response.text}\n        else:\n            # Mock response when Gemini is not configured\n            mock_plan = f\"\"\"\n# {fitness_level.title()} Workout Plan - {goals}\n\n## Equipment: {equipment.title()}\n\n### Week 1-2: Foundation Building\n**Monday - Full Body Strength**\n- Warm-up: 5-10 minutes light cardio\n- Push-ups: 3 sets of 8-12 reps\n- Squats: 3 sets of 12-15 reps\n- Plank: 3 sets of 30-45 seconds\n- Mountain climbers: 3 sets of 20 reps\n- Cool-down: 5 minutes stretching\n\n**Wednesday - Cardio & Core**\n- Jumping jacks: 3 sets of 30 seconds\n- Burpees: 3 sets of 5-8 reps\n- Bicycle crunches: 3 sets of 20 reps\n- High knees: 3 sets of 30 seconds\n- Russian twists: 3 sets of 15 reps each side\n\n**Friday - Upper Body Focus**\n- Push-ups: 3 sets of 8-12 reps\n- Pike push-ups: 3 sets of 6-10 reps\n- Tricep dips: 3 sets of 8-12 reps\n- Arm circles: 2 sets of 15 each direction\n- Wall sits: 3 sets of 30-45 seconds\n\n### Week 3-4: Progression\n- Increase reps by 2-3 per exercise\n- Add 15-30 seconds to hold exercises\n- Include additional sets if comfortable\n- Focus on form and control\n\n### Rest & Recovery\n- Take rest days between workout days\n- Stay hydrated and get adequate sleep\n- Listen to your body and adjust intensity as needed\n\"\"\"\n            return {\"success\": True, \"plan\": mock_plan}\n\n    except Exception as e:\n        logging.error(f\"Failed to generate workout plan: {e}\")\n        return {\"success\": False, \"error\": str(e)}\n\ndef analyze_food_image(image_data: bytes) -> Dict[str, Any]:\n    \"\"\"Analyze food image for nutritional information using Gemini AI\"\"\"\n    try:\n        if GEMINI_CONFIGURED:\n            # Convert image data to base64\n            image_b64 = base64.b64encode(image_data).decode('utf-8')\n\n            prompt = \"\"\"\n            Analyze this food image and provide:\n            1. List of food items you can identify\n            2. Estimated total calories for the portion shown\n            3. Approximate nutritional breakdown (protein, carbs, fats)\n            4. Serving size estimation\n\n            Be specific about portions and provide realistic calorie estimates.\n            If you cannot clearly identify the food, say so.\n\n            Format your response clearly with sections for each part.\n            \"\"\"\n\n            # Create the image part for Gemini using the correct format\n            image_part = {\n                \"mime_type\": \"image/jpeg\",\n                \"data\": image_b64\n            }\n\n            # Use the correct API call for the current version\n            try:\n                response = model.generate_content([prompt, image_part])\n                if response and hasattr(response, 'text'):\n                    return {\"success\": True, \"analysis\": response.text}\n                else:\n                    logging.error(\"Invalid response format from Gemini API\")\n                    return {\"success\": False, \"error\": \"Invalid response from AI model\"}\n            except Exception as api_error:\n                logging.error(f\"Gemini API error: {api_error}\")\n                return {\"success\": False, \"error\": f\"AI analysis failed: {str(api_error)}\"}\n        else:\n            # Mock response when Gemini is not configured\n            mock_analysis = \"\"\"\n**Food Analysis Results:**\n\n**Identified Items:**\n- Mixed salad with lettuce, tomatoes, and cucumbers\n- Grilled chicken breast (approximately 4 oz)\n- Olive oil dressing (1-2 tablespoons)\n\n**Nutritional Estimates:**\n- **Total Calories:** 350-400 calories\n- **Protein:** 35-40g (from chicken)\n- **Carbohydrates:** 8-12g (from vegetables)\n- **Fat:** 15-20g (from dressing and chicken)\n\n**Serving Size:** 1 medium meal portion\n\n**Notes:** This appears to be a healthy, balanced meal with lean protein and fresh vegetables. The calorie estimate assumes a moderate amount of dressing.\n\"\"\"\n            return {\"success\": True, \"analysis\": mock_analysis}\n\n    except Exception as e:\n        logging.error(f\"Failed to analyze food image: {e}\")\n        return {\"success\": False, \"error\": str(e)}\n\ndef get_workout_plan(user_context: str) -> str:\n    \"\"\"Get personalized workout plan using Gemini AI\"\"\"\n    # Extract information from user context\n    fitness_level = re.search(r'Fitness level: (\\w+)', user_context).group(1)\n    equipment = re.search(r'Equipment: (\\w+)', user_context).group(1)\n    goals = re.search(r'Goals: (.+)$', user_context).group(1)\n\n    # Generate the workout plan\n    result = generate_workout_plan(fitness_level, goals, equipment)\n    return result['plan'] if result['success'] else 'Failed to generate workout plan. Please try again.'\n\ndef get_fitness_advice(question: str, user_context: str = \"\") -> str:\n    \"\"\"Get fitness advice using Gemini AI\"\"\"\n    try:\n        if GEMINI_CONFIGURED:\n            prompt = f\"\"\"\n            You are a knowledgeable fitness coach. Answer this fitness question:\n\n            Question: {question}\n\n            User Context: {user_context}\n\n            Provide helpful, accurate, and practical advice. Keep the response concise but informative.\n            If the question is not fitness-related, politely redirect to fitness topics.\n            \"\"\"\n\n            response = model.generate_content(prompt)\n            return response.text\n        else:\n            # Mock response when Gemini is not configured\n            return f\"\"\"\nBased on your question about \"{question}\", here are some general fitness tips:\n\n• **Consistency is key** - Regular exercise, even in small amounts, is better than sporadic intense sessions\n• **Progressive overload** - Gradually increase intensity, duration, or resistance over time\n• **Recovery matters** - Allow adequate rest between workouts for muscle repair and growth\n• **Nutrition support** - Proper nutrition fuels your workouts and aids recovery\n• **Listen to your body** - Adjust intensity based on how you feel\n\nFor personalized advice, consider consulting with a certified fitness trainer or healthcare provider.\n\n*Note: AI fitness advice is currently in demo mode. For full AI-powered responses, configure your Gemini API key.*\n\"\"\"\n\n    except Exception as e:\n        logging.error(f\"Failed to get fitness advice: {e}\")\n        return \"I'm sorry, I'm having trouble processing your request right now. Please try again later.\"\n","size_bytes":8264},"models.py":{"content":"from flask_login import UserMixin\nfrom datetime import datetime\nfrom werkzeug.security import generate_password_hash, check_password_hash\n\n# Import db from extensions to avoid circular imports\nfrom extensions import db\n\nclass User(UserMixin, db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(64), unique=True, nullable=False)\n    email = db.Column(db.String(120), unique=True, nullable=False)\n    password_hash = db.Column(db.String(256))\n    fitness_level = db.Column(db.String(20), default='beginner')\n    fitness_goals = db.Column(db.Text)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n\n    # Relationships\n    food_logs = db.relationship('FoodLog', backref='user', lazy=True, cascade='all, delete-orphan')\n\n    def set_password(self, password):\n        self.password_hash = generate_password_hash(password)\n\n    def check_password(self, password):\n        return check_password_hash(self.password_hash, password)\n\nclass FoodLog(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\n    food_items = db.Column(db.Text)  # JSON string of food items\n    total_calories = db.Column(db.Integer)\n    meal_type = db.Column(db.String(20))  # breakfast, lunch, dinner, snack\n    logged_at = db.Column(db.DateTime, default=datetime.utcnow)\n    image_path = db.Column(db.String(200))\n\nclass Workout(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\n    name = db.Column(db.String(100), nullable=False)\n    exercise_type = db.Column(db.String(50))\n    duration_minutes = db.Column(db.Integer)\n    calories_burned = db.Column(db.Integer)\n    reps_completed = db.Column(db.Integer)\n    form_score = db.Column(db.Float)\n    notes = db.Column(db.Text)\n    completed_at = db.Column(db.DateTime, default=datetime.utcnow)\n    \n    # Relationship\n    user = db.relationship('User', backref=db.backref('workouts', lazy=True, cascade='all, delete-orphan'))\n","size_bytes":2075},"pose_detection.py":{"content":"import numpy as np\nimport logging\nfrom typing import Dict, List, Tuple, Optional\n\nclass PoseAnalyzer:\n    \"\"\"Analyze poses for different exercises and provide form feedback\"\"\"\n\n    def __init__(self):\n        self.exercise_counters = {\n            'pushup': PushupCounter(),\n            'squat': SquatCounter(),\n            'jumping_jack': JumpingJackCounter()\n        }\n\n    def analyze_pose(self, landmarks: List[Dict], exercise_type: str) -> Dict:\n        \"\"\"Analyze pose and return form score and feedback\"\"\"\n        if exercise_type not in self.exercise_counters:\n            return {\"error\": \"Unsupported exercise type\"}\n\n        counter = self.exercise_counters[exercise_type]\n        return counter.analyze(landmarks)\n\nclass PushupCounter:\n    \"\"\"Pushup form analysis and counting\"\"\"\n\n    def __init__(self):\n        self.state = \"up\"  # up, down\n        self.rep_count = 0\n        self.last_angle = 180\n\n    def analyze(self, landmarks: List[Dict]) -> Dict:\n        \"\"\"Analyze pushup form and count reps\"\"\"\n        try:\n            if not landmarks or len(landmarks) < 33:\n                return {\"error\": \"Insufficient landmarks detected\"}\n\n            # Get key points for pushup analysis\n            left_shoulder = landmarks[11]\n            right_shoulder = landmarks[12]\n            left_elbow = landmarks[13]\n            right_elbow = landmarks[14]\n            left_wrist = landmarks[15]\n            right_wrist = landmarks[16]\n            left_hip = landmarks[23]\n            right_hip = landmarks[24]\n\n            # Calculate arm angles\n            left_arm_angle = self._calculate_angle(\n                [left_shoulder['x'], left_shoulder['y']],\n                [left_elbow['x'], left_elbow['y']],\n                [left_wrist['x'], left_wrist['y']]\n            )\n\n            right_arm_angle = self._calculate_angle(\n                [right_shoulder['x'], right_shoulder['y']],\n                [right_elbow['x'], right_elbow['y']],\n                [right_wrist['x'], right_wrist['y']]\n            )\n\n            avg_arm_angle = (left_arm_angle + right_arm_angle) / 2\n\n            # Calculate body alignment (spine straightness)\n            body_alignment_score = self._calculate_body_alignment(\n                left_shoulder, right_shoulder, left_hip, right_hip\n            )\n\n            # Count reps based on arm angle\n            if self.state == \"up\" and avg_arm_angle < 90:\n                self.state = \"down\"\n            elif self.state == \"down\" and avg_arm_angle > 160:\n                self.state = \"up\"\n                self.rep_count += 1\n\n            # Calculate form score (0-100)\n            form_score = self._calculate_pushup_form_score(avg_arm_angle, body_alignment_score)\n\n            # Generate feedback\n            feedback = self._generate_pushup_feedback(avg_arm_angle, body_alignment_score)\n\n            return {\n                \"reps\": self.rep_count,\n                \"form_score\": round(form_score, 1),\n                \"feedback\": feedback,\n                \"arm_angle\": round(avg_arm_angle, 1),\n                \"body_alignment\": round(body_alignment_score, 1)\n            }\n\n        except Exception as e:\n            logging.error(f\"Error in pushup analysis: {e}\")\n            return {\"error\": \"Analysis failed\"}\n\n    def _calculate_angle(self, a: List[float], b: List[float], c: List[float]) -> float:\n        \"\"\"Calculate angle between three points\"\"\"\n        a = np.array(a)\n        b = np.array(b)\n        c = np.array(c)\n\n        radians = np.arctan2(c[1] - b[1], c[0] - b[0]) - np.arctan2(a[1] - b[1], a[0] - b[0])\n        angle = np.abs(radians * 180.0 / np.pi)\n\n        if angle > 180.0:\n            angle = 360 - angle\n\n        return angle\n\n    def _calculate_body_alignment(self, left_shoulder: Dict, right_shoulder: Dict,\n                                left_hip: Dict, right_hip: Dict) -> float:\n        \"\"\"Calculate body alignment score (higher is better)\"\"\"\n        # Check if shoulders and hips are aligned (straight line)\n        shoulder_center = [(left_shoulder['x'] + right_shoulder['x']) / 2,\n                          (left_shoulder['y'] + right_shoulder['y']) / 2]\n        hip_center = [(left_hip['x'] + right_hip['x']) / 2,\n                     (left_hip['y'] + right_hip['y']) / 2]\n\n        # Calculate deviation from straight line\n        vertical_deviation = abs(shoulder_center[1] - hip_center[1])\n\n        # Convert to score (lower deviation = higher score)\n        alignment_score = max(0, 100 - (vertical_deviation * 1000))\n        return min(100, alignment_score)\n\n    def _calculate_pushup_form_score(self, arm_angle: float, body_alignment: float) -> float:\n        \"\"\"Calculate overall form score for pushup\"\"\"\n        # Ideal arm angle range: 60-90 degrees at bottom, 160-180 at top\n        if 60 <= arm_angle <= 90 or 160 <= arm_angle <= 180:\n            angle_score = 100\n        else:\n            angle_score = max(0, 100 - abs(arm_angle - 90) * 2)\n\n        # Combine scores\n        form_score = (angle_score * 0.7) + (body_alignment * 0.3)\n        return min(100, max(0, form_score))\n\n    def _generate_pushup_feedback(self, arm_angle: float, body_alignment: float) -> List[str]:\n        \"\"\"Generate feedback for pushup form\"\"\"\n        feedback = []\n\n        if arm_angle < 60:\n            feedback.append(\"Go deeper - lower your chest more\")\n        elif arm_angle > 120 and arm_angle < 160:\n            feedback.append(\"Push all the way up\")\n\n        if body_alignment < 70:\n            feedback.append(\"Keep your body straight - don't sag or pike\")\n\n        if not feedback:\n            feedback.append(\"Great form!\")\n\n        return feedback\n\n\nclass SquatCounter:\n    \"\"\"Squat form analysis and counting\"\"\"\n\n    def __init__(self):\n        self.state = \"up\"  # up, down\n        self.rep_count = 0\n        self.last_knee_angle = 180\n\n    def analyze(self, landmarks: List[Dict]) -> Dict:\n        \"\"\"Analyze squat form and count reps\"\"\"\n        try:\n            if not landmarks or len(landmarks) < 33:\n                return {\"error\": \"Insufficient landmarks detected\"}\n\n            # Get key points for squat analysis\n            left_hip = landmarks[23]\n            right_hip = landmarks[24]\n            left_knee = landmarks[25]\n            right_knee = landmarks[26]\n            left_ankle = landmarks[27]\n            right_ankle = landmarks[28]\n            left_shoulder = landmarks[11]\n            right_shoulder = landmarks[12]\n\n            # Calculate knee angles\n            left_knee_angle = self._calculate_angle(\n                [left_hip['x'], left_hip['y']],\n                [left_knee['x'], left_knee['y']],\n                [left_ankle['x'], left_ankle['y']]\n            )\n\n            right_knee_angle = self._calculate_angle(\n                [right_hip['x'], right_hip['y']],\n                [right_knee['x'], right_knee['y']],\n                [right_ankle['x'], right_ankle['y']]\n            )\n\n            avg_knee_angle = (left_knee_angle + right_knee_angle) / 2\n\n            # Calculate back alignment\n            back_alignment_score = self._calculate_back_alignment(\n                left_shoulder, right_shoulder, left_hip, right_hip\n            )\n\n            # Count reps based on knee angle\n            if self.state == \"up\" and avg_knee_angle < 110:\n                self.state = \"down\"\n            elif self.state == \"down\" and avg_knee_angle > 160:\n                self.state = \"up\"\n                self.rep_count += 1\n\n            # Calculate form score (0-100)\n            form_score = self._calculate_squat_form_score(avg_knee_angle, back_alignment_score)\n\n            # Generate feedback\n            feedback = self._generate_squat_feedback(avg_knee_angle, back_alignment_score)\n\n            return {\n                \"reps\": self.rep_count,\n                \"form_score\": round(form_score, 1),\n                \"feedback\": feedback,\n                \"knee_angle\": round(avg_knee_angle, 1),\n                \"back_alignment\": round(back_alignment_score, 1)\n            }\n\n        except Exception as e:\n            logging.error(f\"Error in squat analysis: {e}\")\n            return {\"error\": \"Analysis failed\"}\n\n    def _calculate_angle(self, a: List[float], b: List[float], c: List[float]) -> float:\n        \"\"\"Calculate angle between three points\"\"\"\n        a = np.array(a)\n        b = np.array(b)\n        c = np.array(c)\n\n        radians = np.arctan2(c[1] - b[1], c[0] - b[0]) - np.arctan2(a[1] - b[1], a[0] - b[0])\n        angle = np.abs(radians * 180.0 / np.pi)\n\n        if angle > 180.0:\n            angle = 360 - angle\n\n        return angle\n\n    def _calculate_back_alignment(self, left_shoulder: Dict, right_shoulder: Dict,\n                                left_hip: Dict, right_hip: Dict) -> float:\n        \"\"\"Calculate back alignment score (higher is better)\"\"\"\n        # Check if shoulders and hips are aligned (vertical line)\n        shoulder_center = [(left_shoulder['x'] + right_shoulder['x']) / 2,\n                          (left_shoulder['y'] + right_shoulder['y']) / 2]\n        hip_center = [(left_hip['x'] + right_hip['x']) / 2,\n                     (left_hip['y'] + right_hip['y']) / 2]\n\n        # Calculate horizontal deviation (should be minimal for good squat form)\n        horizontal_deviation = abs(shoulder_center[0] - hip_center[0])\n\n        # Convert to score (lower deviation = higher score)\n        alignment_score = max(0, 100 - (horizontal_deviation * 1000))\n        return min(100, alignment_score)\n\n    def _calculate_squat_form_score(self, knee_angle: float, back_alignment: float) -> float:\n        \"\"\"Calculate overall form score for squat\"\"\"\n        # Ideal knee angle range: 70-100 degrees at bottom, 160-180 at top\n        if 70 <= knee_angle <= 100 or 160 <= knee_angle <= 180:\n            angle_score = 100\n        else:\n            angle_score = max(0, 100 - abs(knee_angle - 90) * 2)\n\n        # Combine scores\n        form_score = (angle_score * 0.7) + (back_alignment * 0.3)\n        return min(100, max(0, form_score))\n\n    def _generate_squat_feedback(self, knee_angle: float, back_alignment: float) -> List[str]:\n        \"\"\"Generate feedback for squat form\"\"\"\n        feedback = []\n\n        if knee_angle < 70:\n            feedback.append(\"Be careful not to go too deep\")\n        elif knee_angle > 110 and knee_angle < 160:\n            feedback.append(\"Stand up fully between reps\")\n        elif knee_angle > 100 and knee_angle < 110:\n            feedback.append(\"Go deeper for full range of motion\")\n\n        if back_alignment < 70:\n            feedback.append(\"Keep your back straight - chest up\")\n\n        if not feedback:\n            feedback.append(\"Great form!\")\n\n        return feedback\n\n\nclass JumpingJackCounter:\n    \"\"\"Jumping jack form analysis and counting\"\"\"\n\n    def __init__(self):\n        self.state = \"closed\"  # closed, open\n        self.rep_count = 0\n        self.last_arm_distance = 0\n\n    def analyze(self, landmarks: List[Dict]) -> Dict:\n        \"\"\"Analyze jumping jack form and count reps\"\"\"\n        try:\n            if not landmarks or len(landmarks) < 33:\n                return {\"error\": \"Insufficient landmarks detected\"}\n\n            # Get key points for jumping jack analysis\n            left_shoulder = landmarks[11]\n            right_shoulder = landmarks[12]\n            left_wrist = landmarks[15]\n            right_wrist = landmarks[16]\n            left_ankle = landmarks[27]\n            right_ankle = landmarks[28]\n            left_hip = landmarks[23]\n            right_hip = landmarks[24]\n\n            # Calculate arm spread (distance between wrists relative to shoulders)\n            shoulder_width = abs(right_shoulder['x'] - left_shoulder['x'])\n            wrist_distance = abs(right_wrist['x'] - left_wrist['x']) / shoulder_width\n\n            # Calculate leg spread (distance between ankles relative to hips)\n            hip_width = abs(right_hip['x'] - left_hip['x'])\n            ankle_distance = abs(right_ankle['x'] - left_ankle['x']) / hip_width\n\n            # Calculate symmetry (arms and legs should move together)\n            symmetry_score = self._calculate_symmetry(\n                wrist_distance, ankle_distance\n            )\n\n            # Count reps based on arm and leg position\n            if self.state == \"closed\" and wrist_distance > 1.5 and ankle_distance > 1.5:\n                self.state = \"open\"\n            elif self.state == \"open\" and wrist_distance < 1.2 and ankle_distance < 1.2:\n                self.state = \"closed\"\n                self.rep_count += 1\n\n            # Calculate form score (0-100)\n            form_score = self._calculate_jumping_jack_form_score(wrist_distance, ankle_distance, symmetry_score)\n\n            # Generate feedback\n            feedback = self._generate_jumping_jack_feedback(wrist_distance, ankle_distance, symmetry_score)\n\n            return {\n                \"reps\": self.rep_count,\n                \"form_score\": round(form_score, 1),\n                \"feedback\": feedback,\n                \"arm_spread\": round(wrist_distance, 2),\n                \"leg_spread\": round(ankle_distance, 2),\n                \"symmetry\": round(symmetry_score, 1)\n            }\n\n        except Exception as e:\n            logging.error(f\"Error in jumping jack analysis: {e}\")\n            return {\"error\": \"Analysis failed\"}\n\n    def _calculate_symmetry(self, arm_spread: float, leg_spread: float) -> float:\n        \"\"\"Calculate symmetry score between arm and leg movement\"\"\"\n        # Perfect symmetry would have arms and legs moving in sync\n        movement_diff = abs(arm_spread - leg_spread)\n\n        # Convert to score (lower difference = higher score)\n        symmetry_score = max(0, 100 - (movement_diff * 100))\n        return min(100, symmetry_score)\n\n    def _calculate_jumping_jack_form_score(self, arm_spread: float, leg_spread: float, symmetry: float) -> float:\n        \"\"\"Calculate overall form score for jumping jack\"\"\"\n        # Ideal arm spread: >1.8 when open, <1.2 when closed\n        if (arm_spread > 1.8 and self.state == \"open\") or (arm_spread < 1.2 and self.state == \"closed\"):\n            arm_score = 100\n        else:\n            arm_score = max(0, 100 - abs(arm_spread - (1.8 if self.state == \"open\" else 1.0)) * 50)\n\n        # Ideal leg spread: >1.5 when open, <1.2 when closed\n        if (leg_spread > 1.5 and self.state == \"open\") or (leg_spread < 1.2 and self.state == \"closed\"):\n            leg_score = 100\n        else:\n            leg_score = max(0, 100 - abs(leg_spread - (1.5 if self.state == \"open\" else 1.0)) * 50)\n\n        # Combine scores\n        form_score = (arm_score * 0.4) + (leg_score * 0.4) + (symmetry * 0.2)\n        return min(100, max(0, form_score))\n\n    def _generate_jumping_jack_feedback(self, arm_spread: float, leg_spread: float, symmetry: float) -> List[str]:\n        \"\"\"Generate feedback for jumping jack form\"\"\"\n        feedback = []\n\n        if arm_spread < 1.5 and self.state == \"open\":\n            feedback.append(\"Raise your arms higher\")\n\n        if leg_spread < 1.3 and self.state == \"open\":\n            feedback.append(\"Jump wider with your legs\")\n\n        if symmetry < 70:\n            feedback.append(\"Coordinate your arms and legs to move together\")\n\n        if not feedback:\n            feedback.append(\"Great form!\")\n\n        return feedback","size_bytes":15233},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"email-validator>=2.3.0\",\n    \"fla>=0.6.3\",\n    \"flask>=3.1.2\",\n    \"flask-sqlalchemy>=3.1.1\",\n    \"google-genai>=1.32.0\",\n    \"gunicorn>=23.0.0\",\n    \"numpy>=1.26.4\",\n    \"pillow>=11.3.0\",\n    \"psycopg2-binary>=2.9.10\",\n    \"pydantic>=2.11.7\",\n    \"sift-stack-py>=0.8.4\",\n    \"sqlalchemy>=2.0.43\",\n    \"werkzeug>=3.1.3\",\n    \"opencv-python>=4.11.0.86\",\n    \"mediapipe>=0.10.21\",\n]\n","size_bytes":528},"routes.py":{"content":"from flask import render_template, request, redirect, url_for, flash, jsonify, session\nfrom flask_login import login_user, logout_user, login_required, current_user\nfrom werkzeug.utils import secure_filename\nimport os\nimport json\nimport base64\nfrom PIL import Image\nimport io\nimport logging\nfrom datetime import datetime, timedelta\nimport numpy as np\n\n# Handle optional cv2 import\ntry:\n    import cv2\n    CV2_AVAILABLE = True\nexcept ImportError:\n    CV2_AVAILABLE = False\n    logging.warning(\"OpenCV (cv2) not available. Some pose detection features may be limited.\")\n\n# Import db from extensions to avoid circular imports\nfrom extensions import db\nfrom models import User, FoodLog, Workout\nimport gemini\nfrom pose_detection import PoseAnalyzer\n\n\n# Global app variable that will be set by the main app\napp = None\n\n# Initialize pose analyzer\npose_analyzer = PoseAnalyzer()\n\ndef set_app(flask_app):\n    \"\"\"Set the Flask app instance for route registration\"\"\"\n    global app\n    app = flask_app\n\n# Route definitions\ndef register_routes(flask_app):\n    \"\"\"Register all routes with the Flask app\"\"\"\n    global app\n    app = flask_app\n\n    @app.route('/')\n    def index():\n        return render_template('index.html')\n\n\n    @app.route('/register', methods=['GET', 'POST'])\n    def register():\n        if request.method == 'POST':\n            username = request.form['username']\n            email = request.form['email']\n            password = request.form['password']\n            fitness_level = request.form.get('fitness_level', 'beginner')\n            fitness_goals = request.form.get('fitness_goals', '')\n\n            # Check if user exists\n            if User.query.filter_by(username=username).first():\n                flash('Username already exists')\n                return render_template('register.html')\n\n            if User.query.filter_by(email=email).first():\n                flash('Email already registered')\n                return render_template('register.html')\n\n            # Create new user\n            user = User(\n                username=username, \n                email=email, \n                fitness_level=fitness_level,\n                fitness_goals=fitness_goals\n            )\n            user.set_password(password)\n            db.session.add(user)\n            db.session.commit()\n\n            login_user(user)\n            return redirect(url_for('dashboard'))\n\n        return render_template('register.html')\n\n    @app.route('/login', methods=['GET', 'POST'])\n    def login():\n        if request.method == 'POST':\n            username = request.form['username']\n            password = request.form['password']\n\n            user = User.query.filter_by(username=username).first()\n\n            if user and user.check_password(password):\n                login_user(user)\n                next_page = request.args.get('next')\n                return redirect(next_page) if next_page else redirect(url_for('dashboard'))\n            else:\n                flash('Invalid username or password')\n\n        return render_template('login.html')\n\n    @app.route('/logout')\n    @login_required\n    def logout():\n        logout_user()\n        return redirect(url_for('index'))\n\n    @app.route('/dashboard')\n    @login_required\n    def dashboard():\n        # Get user's recent food logs\n        recent_food_logs = FoodLog.query.filter_by(user_id=current_user.id).order_by(FoodLog.logged_at.desc()).limit(5).all()\n        return render_template('dashboard.html', recent_food_logs=recent_food_logs)\n\n    @app.route('/exercise-analysis')\n    @login_required\n    def exercise_analysis():\n        \"\"\"Render the exercise analysis page\"\"\"\n        return render_template('exercise_analysis.html')\n\n    @app.route('/api/analyze-pose', methods=['POST'])\n    @login_required\n    def analyze_pose():\n        \"\"\"API endpoint for real-time pose analysis\"\"\"\n        try:\n            data = request.json\n            landmarks = data.get('landmarks')\n            exercise_type = data.get('exercise_type')\n\n            if not landmarks or not exercise_type:\n                return jsonify({'error': 'Missing landmarks or exercise type'}), 400\n\n            # Analyze pose using the PoseAnalyzer\n            result = pose_analyzer.analyze_pose(landmarks, exercise_type)\n            return jsonify(result)\n\n        except Exception as e:\n            logging.error(f\"Error in pose analysis: {e}\")\n            return jsonify({'error': 'Analysis failed'}), 500\n\n    @app.route('/workout_planner', methods=['GET', 'POST'])\n    @login_required\n    def workout_planner():\n        \"\"\"Render the workout planner page and handle form submissions\"\"\"\n        if request.method == 'POST':\n            try:\n                fitness_level = request.form.get('fitness_level')\n                equipment = request.form.get('equipment')\n                goals = request.form.get('goals')\n\n                # Get user context\n                user_context = f\"Fitness level: {fitness_level}, Equipment: {equipment}, Goals: {goals}\"\n\n                # Get AI response for workout plan\n                plan = gemini.get_workout_plan(user_context)\n\n                return render_template('workout_planner.html', plan=plan)\n\n            except Exception as e:\n                flash('Error generating workout plan. Please try again.', 'error')\n                return render_template('workout_planner.html')\n\n        return render_template('workout_planner.html')\n\n    @app.route('/exercise_tracker')\n    @login_required\n    def exercise_tracker():\n        \"\"\"Render the exercise tracker page\"\"\"\n        return render_template('exercise_tracker.html')\n\n\n\n    @app.route('/food-analyzer', methods=['GET', 'POST'])\n    @login_required\n    def food_analyzer():\n        if request.method == 'POST':\n            if 'food_image' not in request.files:\n                flash('No image uploaded')\n                return redirect(request.url)\n\n            file = request.files['food_image']\n            if file.filename == '':\n                flash('No image selected')\n                return redirect(request.url)\n\n            if file:\n                try:\n                    # Read image data\n                    image_data = file.read()\n\n                    # Analyze using AI\n                    result = gemini.analyze_food_image(image_data)\n\n                    if result['success']:\n                        # Parse the analysis result\n                        analysis_text = result['analysis']\n\n                        # Extract calories from analysis text\n                        import re\n                        calorie_patterns = [\n                            r'total.*?(\\d+).*?calorie',\n                            r'(\\d+).*?total.*?calorie',\n                            r'calories?[:\\s]*(\\d+)',\n                            r'(\\d+)[- ]*(\\d+)?\\s*calorie',\n                            r'approximately?\\s*(\\d+)'\n                        ]\n\n                        estimated_calories = 0\n                        for pattern in calorie_patterns:\n                            calorie_match = re.search(pattern, analysis_text.lower())\n                            if calorie_match:\n                                estimated_calories = int(calorie_match.group(1))\n                                break\n\n                        # If no calories found, provide a default estimate\n                        if estimated_calories == 0:\n                            estimated_calories = 250  # Default reasonable estimate\n\n                        # Save food log\n                        meal_type = request.form.get('meal_type', 'snack')\n                        food_log = FoodLog(\n                            user_id=current_user.id,\n                            food_items=analysis_text,\n                            total_calories=estimated_calories,\n                            meal_type=meal_type\n                        )\n                        db.session.add(food_log)\n                        db.session.commit()\n\n                        flash('Food analysis completed successfully!', 'success')\n                        return render_template('food_analyzer.html', \n                                             analysis=analysis_text,\n                                             estimated_calories=estimated_calories)\n                    else:\n                        flash(f'Error analyzing food: {result[\"error\"]}')\n\n                except Exception as e:\n                    logging.error(f\"Error processing food image: {e}\")\n                    flash('Error processing image. Please try again with a clearer photo.', 'danger')\n                    return render_template('food_analyzer.html')\n\n        return render_template('food_analyzer.html')\n\n\n\n    @app.route('/api/food-analysis', methods=['POST'])\n    @login_required\n    def food_analysis_api():\n        try:\n            # Get image data from request\n            if 'image' not in request.files:\n                return jsonify({'success': False, 'error': 'No image provided'})\n\n            image_file = request.files['image']\n\n            # Process image with food analysis\n            result = gemini.analyze_food_image(image_file)\n\n            return jsonify({'success': True, 'data': result})\n\n        except Exception as e:\n            logging.error(f\"Error in food analysis API: {e}\")\n            return jsonify({'success': False, 'error': str(e)})\n\n\n\n            db.session.add(workout)\n            db.session.flush()  # Get the workout ID\n\n            # Add exercises\n            for exercise_data in data.get('exercises', []):\n                exercise = Exercise(\n                    workout_id=workout.id,\n                    name=exercise_data.get('name', ''),\n                    reps=exercise_data.get('reps', 0),\n                    sets=exercise_data.get('sets', 1),\n                    form_accuracy=exercise_data.get('form_accuracy', 0),\n                    exercise_type=exercise_data.get('exercise_type', 'cardio')\n                )\n                db.session.add(exercise)\n\n            db.session.commit()\n\n            return jsonify({\n                'success': True,\n                'message': 'Workout saved successfully',\n                'workout_id': workout.id\n            })\n\n        except Exception as e:\n            db.session.rollback()\n            logging.error(f\"Error saving workout: {e}\")\n            return jsonify({\n                'success': False,\n                'error': 'Failed to save workout'\n            })\n\n    @app.route('/api/fitness-chat', methods=['POST'])\n    @login_required\n    def fitness_chat():\n        try:\n            data = request.get_json()\n            question = data.get('question', '')\n\n            if not question:\n                return jsonify({'success': False, 'error': 'No question provided'})\n\n            # Get user context\n            user_context = f\"Fitness level: {current_user.fitness_level}, Goals: {current_user.fitness_goals}\"\n\n            # Get AI response\n            response = gemini.get_fitness_advice(question, user_context)\n\n            return jsonify({'success': True, 'response': response})\n\n        except Exception as e:\n            logging.error(f\"Error in fitness chat: {e}\")\n            return jsonify({'success': False, 'error': 'Sorry, I had trouble processing your request.'})\n\n    @app.route('/api/dashboard-stats')\n    @login_required\n    def dashboard_stats():\n        \"\"\"Get dashboard statistics for charts\"\"\"\n        try:\n            # Get workout history for last 30 days\n            thirty_days_ago = datetime.utcnow() - timedelta(days=30)\n\n            workouts = Workout.query.filter(\n                Workout.user_id == current_user.id,\n                Workout.completed_at >= thirty_days_ago\n            ).all()\n\n            # Prepare data for charts\n            workout_dates = []\n            calories_burned = []\n\n            for workout in workouts:\n                workout_dates.append(workout.completed_at.strftime('%Y-%m-%d'))\n                calories_burned.append(workout.calories_burned or 0)\n\n            return jsonify({\n                'success': True,\n                'data': {\n                    'workout_dates': workout_dates,\n                    'calories_burned': calories_burned,\n                    'total_workouts': len(workouts),\n                    'avg_calories': sum(calories_burned) / len(calories_burned) if calories_burned else 0\n                }\n            })\n\n        except Exception as e:\n            logging.error(f\"Error getting dashboard stats: {e}\")\n            return jsonify({'success': False, 'error': str(e)})\n\n\n\n            workout = Workout(\n                user_id=current_user.id,\n                name=data.get('name', 'Custom Workout'),\n                exercises=json.dumps(data.get('exercises', [])),\n                duration=data.get('duration', 0),\n                calories_burned=data.get('calories_burned', 0),\n                difficulty=data.get('difficulty', 'medium')\n            )\n\n            db.session.add(workout)\n            db.session.commit()\n\n            return jsonify({'success': True, 'message': 'Workout recorded successfully!'})\n\n        except Exception as e:\n            logging.error(f\"Error recording workout: {e}\")\n            return jsonify({'success': False, 'error': str(e)})\n\n    # All workout-related code has been removed\n\n    @app.route('/api/save-food-log', methods=['POST'])\n    @login_required\n    def save_food_log():\n        try:\n            data = request.get_json()\n\n            food_log = FoodLog(\n                user_id=current_user.id,\n                food_items=json.dumps(data.get('food_items', [])),\n                total_calories=data.get('total_calories', 0),\n                meal_type=data.get('meal_type', 'snack')\n            )\n\n            db.session.add(food_log)\n            db.session.commit()\n\n            return jsonify({'success': True, 'message': 'Food log saved successfully!'})\n\n        except Exception as e:\n            logging.error(f\"Error saving food log: {e}\")\n            return jsonify({'success': False, 'error': str(e)})\n\n    # All workout-related code has been removed\n\n    @app.route('/api/get-food-history')\n    @login_required\n    def get_food_history():\n        try:\n            food_logs = FoodLog.query.filter_by(user_id=current_user.id).order_by(FoodLog.logged_at.desc()).all()\n\n            food_data = []\n            for log in food_logs:\n                food_data.append({\n                    'id': log.id,\n                    'food_items': json.loads(log.food_items) if log.food_items else [],\n                    'total_calories': log.total_calories,\n                    'meal_type': log.meal_type,\n                    'logged_at': log.logged_at.strftime('%Y-%m-%d %H:%M:%S')\n                })\n\n            return jsonify({'success': True, 'data': food_data})\n\n        except Exception as e:\n            logging.error(f\"Error getting food history: {e}\")\n            return jsonify({'success': False, 'error': str(e)})\n\n    @app.route('/api/update-profile', methods=['POST'])\n    @login_required\n    def update_profile():\n        try:\n            data = request.get_json()\n\n            current_user.fitness_level = data.get('fitness_level', current_user.fitness_level)\n            current_user.fitness_goals = data.get('fitness_goals', current_user.fitness_goals)\n\n            db.session.commit()\n\n            return jsonify({'success': True, 'message': 'Profile updated successfully!'})\n\n        except Exception as e:\n            logging.error(f\"Error updating profile: {e}\")\n            return jsonify({'success': False, 'error': str(e)})\n\n\n\n    @app.route('/api/delete-food-log/<int:log_id>', methods=['DELETE'])\n    @login_required\n    def delete_food_log(log_id):\n        try:\n            food_log = FoodLog.query.filter_by(id=log_id, user_id=current_user.id).first()\n\n            if not food_log:\n                return jsonify({'success': False, 'error': 'Food log not found'}), 404\n\n            db.session.delete(food_log)\n            db.session.commit()\n\n            return jsonify({'success': True, 'message': 'Food log deleted successfully!'})\n\n        except Exception as e:\n            logging.error(f\"Error deleting food log: {e}\")\n            return jsonify({'success': False, 'error': str(e)})\n\n    @app.route('/api/export-data')\n    @login_required\n    def export_data():\n        try:\n            # Get user's data\n            workouts = Workout.query.filter_by(user_id=current_user.id).all()\n            food_logs = FoodLog.query.filter_by(user_id=current_user.id).all()\n\n            # Prepare export data\n            export_data = {\n                'user_info': {\n                    'username': current_user.username,\n                    'email': current_user.email,\n                    'fitness_level': current_user.fitness_level,\n                    'fitness_goals': current_user.fitness_goals\n                },\n                'workouts': [],\n                'food_logs': []\n            }\n\n            for workout in workouts:\n                export_data['workouts'].append({\n                    'name': workout.name,\n                    'duration': workout.duration,\n                    'calories_burned': workout.calories_burned,\n                    'completed_at': workout.completed_at.strftime('%Y-%m-%d %H:%M:%S'),\n                    'difficulty': workout.difficulty\n                })\n\n            for log in food_logs:\n                export_data['food_logs'].append({\n                    'food_items': json.loads(log.food_items) if log.food_items else [],\n                    'total_calories': log.total_calories,\n                    'meal_type': log.meal_type,\n                    'logged_at': log.logged_at.strftime('%Y-%m-%d %H:%M:%S')\n                })\n\n            return jsonify({'success': True, 'data': export_data})\n\n        except Exception as e:\n            logging.error(f\"Error exporting data: {e}\")\n            return jsonify({'success': False, 'error': str(e)})\n\n    @app.route('/api/import-data', methods=['POST'])\n    @login_required\n    def import_data():\n        try:\n            data = request.get_json()\n\n            # Import workouts\n            for workout_data in data.get('workouts', []):\n                workout = Workout(\n                    user_id=current_user.id,\n                    name=workout_data.get('name', 'Imported Workout'),\n                    duration=workout_data.get('duration', 0),\n                    calories_burned=workout_data.get('calories_burned', 0),\n                    difficulty=workout_data.get('difficulty', 'medium')\n                )\n                db.session.add(workout)\n\n            # Import food logs\n            for log_data in data.get('food_logs', []):\n                food_log = FoodLog(\n                    user_id=current_user.id,\n                    food_items=json.dumps(log_data.get('food_items', [])),\n                    total_calories=log_data.get('total_calories', 0),\n                    meal_type=log_data.get('meal_type', 'snack')\n                )\n                db.session.add(food_log)\n\n            db.session.commit()\n\n            return jsonify({'success': True, 'message': 'Data imported successfully!'})\n\n        except Exception as e:\n            db.session.rollback()\n            logging.error(f\"Error importing data: {e}\")\n            return jsonify({'success': False, 'error': str(e)})\n\n    @app.route('/api/backup-data')\n    @login_required\n    def backup_data():\n        try:\n            # Get user's data\n            workouts = Workout.query.filter_by(user_id=current_user.id).all()\n            food_logs = FoodLog.query.filter_by(user_id=current_user.id).all()\n\n            # Create backup data\n            backup_data = {\n                'timestamp': datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S'),\n                'user_id': current_user.id,\n                'workouts': [],\n                'food_logs': []\n            }\n\n            for workout in workouts:\n                backup_data['workouts'].append({\n                    'name': workout.name,\n                    'duration': workout.duration,\n                    'calories_burned': workout.calories_burned,\n                    'completed_at': workout.completed_at.strftime('%Y-%m-%d %H:%M:%S'),\n                    'difficulty': workout.difficulty\n                })\n\n            for log in food_logs:\n                backup_data['food_logs'].append({\n                    'food_items': json.loads(log.food_items) if log.food_items else [],\n                    'total_calories': log.total_calories,\n                    'meal_type': log.meal_type,\n                    'logged_at': log.logged_at.strftime('%Y-%m-%d %H:%M:%S')\n                })\n\n            return jsonify({'success': True, 'data': backup_data})\n\n        except Exception as e:\n            logging.error(f\"Error creating backup: {e}\")\n            return jsonify({'success': False, 'error': str(e)})\n\n    @app.route('/api/restore-data', methods=['POST'])\n    @login_required\n    def restore_data():\n        try:\n            data = request.get_json()\n\n            # Clear existing data\n            Workout.query.filter_by(user_id=current_user.id).delete()\n            FoodLog.query.filter_by(user_id=current_user.id).delete()\n\n            # Restore workouts\n            for workout_data in data.get('workouts', []):\n                workout = Workout(\n                    user_id=current_user.id,\n                    name=workout_data.get('name', 'Restored Workout'),\n                    duration=workout_data.get('duration', 0),\n                    calories_burned=workout_data.get('calories_burned', 0),\n                    difficulty=workout_data.get('difficulty', 'medium')\n                )\n                db.session.add(workout)\n\n            # Restore food logs\n            for log_data in data.get('food_logs', []):\n                food_log = FoodLog(\n                    user_id=current_user.id,\n                    food_items=json.dumps(log_data.get('food_items', [])),\n                    total_calories=log_data.get('total_calories', 0),\n                    meal_type=log_data.get('meal_type', 'snack')\n                )\n                db.session.add(food_log)\n\n            db.session.commit()\n\n            return jsonify({'success': True, 'message': 'Data restored successfully!'})\n\n        except Exception as e:\n            db.session.rollback()\n            logging.error(f\"Error restoring data: {e}\")\n            return jsonify({'success': False, 'error': str(e)})\n\n    @app.route('/api/clear-data', methods=['POST'])\n    @login_required\n    def clear_data():\n        try:\n            # Clear all user data\n            Workout.query.filter_by(user_id=current_user.id).delete()\n            FoodLog.query.filter_by(user_id=current_user.id).delete()\n\n            db.session.commit()\n\n            return jsonify({'success': True, 'message': 'All data cleared successfully!'})\n\n        except Exception as e:\n            db.session.rollback()\n            logging.error(f\"Error clearing data: {e}\")\n            return jsonify({'success': False, 'error': str(e)})\n\n    @app.route('/api/health-check')\n    def health_check():\n        return jsonify({'status': 'healthy', 'timestamp': datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')})\n\n    @app.route('/api/version')\n    def version():\n        return jsonify({'version': '1.0.0', 'name': 'VisionFitAI'})\n\n    @app.route('/api/pose-detection', methods=['POST'])\n    @login_required\n    def pose_detection_api():\n        try:\n            # Get image data from request\n            if 'image' not in request.files and 'image_data' not in request.form:\n                return jsonify({'success': False, 'error': 'No image provided'})\n\n            # Process image data\n            if 'image' in request.files:\n                image_file = request.files['image']\n                image_data = image_file.read()\n            else:\n                # Handle base64 encoded image\n                image_data = base64.b64decode(request.form['image_data'].split(',')[1])\n\n            # Get exercise type\n            exercise_type = request.form.get('exercise_type', 'pushup')\n\n            # Convert to OpenCV format\n            nparr = np.frombuffer(image_data, np.uint8)\n            img = cv2.imdecode(nparr, cv2.IMREAD_COLOR)\n\n            # Use PoseDetector to process the image\n            detector = PoseDetector()\n            result = detector.process_image(img)\n\n            if result['success']:\n                return jsonify({\n                    'success': True,\n                    'message': 'Pose detection successful',\n                    'landmarks': result.get('landmarks', [])\n                })\n            else:\n                return jsonify({\n                    'success': False,\n                    'error': result.get('message', 'Failed to detect pose')\n                })\n\n        except Exception as e:\n            logging.error(f\"Error in pose detection API: {e}\")\n            return jsonify({'success': False, 'error': str(e)})\n\n    @app.route('/api/docs')\n    def api_docs():\n        return jsonify({\n            'endpoints': [\n                '/api/pose-detection',\n                '/api/food-analysis',\n                '/api/fitness-chat',\n                '/api/dashboard-stats',\n                '/api/complete-workout',\n                '/api/save-food-log',\n                '/api/get-workout-history',\n                '/api/get-food-history',\n                '/api/update-profile',\n                '/api/delete-workout/<id>',\n                '/api/delete-food-log/<id>',\n                '/api/export-data',\n                '/api/import-data',\n                '/api/backup-data',\n                '/api/restore-data',\n                '/api/clear-data',\n                '/api/health-check',\n                '/api/version',\n                '/api/docs'\n            ]\n        })\n\n\n","size_bytes":25842},"run.py":{"content":"import sys\nimport os\n\n# Add the parent directory to sys.path\nsys.path.insert(0, os.path.abspath(os.path.dirname(__file__)))\n\n# Now import and run the app\nfrom VisionFitAI.app import app\n\nif __name__ == '__main__':\n    app.run(host='127.0.0.1', port=5000, debug=True)","size_bytes":266},"static/css/style.css":{"content":"/* VisionFit AI - Custom Styles */\n\n/* Color Variables */\n:root {\n    --primary: #FF6B35;\n    --secondary: #004E89;\n    --accent: #00A8CC;\n    --background: #F7F9FC;\n    --success: #2ECC71;\n    --text: #2C3E50;\n    --white: #FFFFFF;\n    --light-gray: #F1F5F9;\n    --border-light: #E2E8F0;\n    --border-radius: 12px;\n    --gradient-primary: linear-gradient(135deg, var(--primary), #FF8F5E);\n}\n\n/* Global Styles */\n* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Inter', 'Roboto', -apple-system, BlinkMacSystemFont, sans-serif;\n    background-color: var(--background);\n    color: var(--text);\n    line-height: 1.6;\n    overflow-x: hidden;\n}\n\nh1, h2, h3, h4, h5, h6 {\n    font-family: 'Montserrat', sans-serif;\n    font-weight: 600;\n    letter-spacing: -0.025em;\n}\n\nh1 {\n    font-size: 2.5rem;\n    margin-bottom: 1.5rem;\n}\n\nh2 {\n    font-size: 2rem;\n    margin-bottom: 1.25rem;\n}\n\nh3 {\n    font-size: 1.75rem;\n    margin-bottom: 1rem;\n}\n\np {\n    font-family: 'Inter', sans-serif;\n    margin-bottom: 1rem;\n}\n\n.font-montserrat {\n    font-family: 'Montserrat', sans-serif;\n}\n\n.font-inter {\n    font-family: 'Inter', sans-serif;\n}\n\n.font-roboto {\n    font-family: 'Roboto', sans-serif;\n}\n\n/* Custom Scrollbar */\n::-webkit-scrollbar {\n    width: 8px;\n}\n\n::-webkit-scrollbar-track {\n    background: var(--light-gray);\n}\n\n::-webkit-scrollbar-thumb {\n    background: var(--primary);\n    border-radius: 4px;\n}\n\n::-webkit-scrollbar-thumb:hover {\n    background: var(--accent);\n}\n\n/* Exercise Analyzer Styles */\n.exercises-list { \n    display: flex; \n    flex-direction: column; \n    gap: 1rem; \n} \n\n.exercise-item { \n    padding: 1.5rem; \n} \n\n.exercise-header { \n    display: flex; \n    align-items: center; \n    gap: 1rem; \n} \n\n.exercise-number { \n    width: 40px; \n    height: 40px; \n    background: var(--gradient-primary); \n    border-radius: 50%; \n    display: flex; \n    align-items: center; \n    justify-content: center; \n    font-weight: 700; \n    color: white; \n} \n\n\n\n.exercise-description { \n    margin-top: 1rem; \n    padding-left: 56px; \n} \n\n/* Exercise Tracker Styles */ \n.exercise-tracker-container { \n    padding-top: 80px; \n} \n\n.camera-card { \n    padding: 1rem; \n} \n\n.camera-container { \n    position: relative; \n    width: 100%; \n    height: 500px; \n    border-radius: var(--border-radius); \n    overflow: hidden; \n    background: #000; \n} \n\n.camera-feed { \n    width: 100%; \n    height: 100%; \n    object-fit: cover; \n} \n\n.pose-overlay { \n    position: absolute; \n    top: 0; \n    left: 0; \n    width: 100%; \n    height: 100%; \n} \n\n.feedback-overlay { \n    position: absolute; \n    top: 1rem; \n    left: 1rem; \n    display: flex; \n    gap: 1rem; \n} \n\n.rep-counter, .form-score { \n    padding: 1rem; \n    text-align: center; \n    min-width: 100px; \n} \n\n.counter-label, .score-label { \n    font-size: 0.8rem; \n    color: var(--text); \n    margin-bottom: 0.5rem; \n} \n\n.counter-value, .score-value { \n    font-size: 2rem; \n    font-weight: 700; \n    color: var(--primary); \n} \n\n.live-feedback { \n    position: absolute; \n    bottom: 1rem; \n    left: 1rem; \n    right: 1rem; \n    display: flex; \n    flex-direction: column; \n    gap: 0.5rem; \n} \n\n.feedback-message { \n    padding: 0.75rem 1rem; \n    background: rgba(168, 85, 247, 0.9); \n    color: white; \n    border-radius: var(--border-radius); \n    font-weight: 500; \n} \n\n.camera-placeholder { \n    position: absolute; \n    top: 0; \n    left: 0; \n    width: 100%; \n    height: 100%; \n    display: flex; \n    align-items: center; \n    justify-content: center; \n    background: rgba(248, 249, 250, 0.9); \n} \n\n.placeholder-content { \n    text-align: center; \n} \n\n.exercise-select { \n    padding: 1.5rem; \n} \n\n.exercise-options { \n    display: flex; \n    flex-direction: column; \n    gap: 1rem; \n} \n\n.exercise-option { \n    display: flex; \n    align-items: center; \n    gap: 1rem; \n    padding: 1rem; \n    border-radius: var(--border-radius); \n    background: var(--light-gray); \n    border: 2px solid transparent; \n    cursor: pointer; \n    transition: all 0.3s ease; \n} \n\n.exercise-option:hover { \n    background: var(--light-gray); \n    border-color: var(--primary); \n} \n\n.exercise-option.active { \n    background: rgba(255, 107, 53, 0.1); \n    border-color: var(--primary); \n}\n\n/* Navigation Enhancements */\n.navbar {\n    backdrop-filter: blur(8px);\n    -webkit-backdrop-filter: blur(8px);\n    background-color: rgba(255, 255, 255, 0.9);\n    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n    box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);\n    padding: 1rem 0;\n}\n\n.navbar-brand {\n    font-family: 'Montserrat', sans-serif;\n    font-weight: 700;\n    font-size: 1.5rem;\n    color: var(--text);\n    letter-spacing: -0.025em;\n}\n\n.navbar-brand:hover {\n    color: var(--primary);\n}\n\n.nav-link {\n    font-weight: 500;\n    font-size: 0.95rem;\n    color: var(--text);\n    padding: 0.5rem 1rem;\n    border-radius: var(--border-radius);\n    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n    margin: 0 0.25rem;\n}\n\n.nav-link:hover {\n    color: var(--primary);\n    background-color: var(--light-gray);\n}\n\n.nav-link.active {\n    color: var(--primary);\n    background-color: rgba(99, 102, 241, 0.1);\n}\n\n/* Button Styles */\n.btn {\n    font-weight: 500;\n    border-radius: var(--border-radius);\n    padding: 0.75rem 1.75rem;\n    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n    border: none;\n    position: relative;\n    overflow: hidden;\n    letter-spacing: 0.025em;\n}\n\n.btn-primary {\n    background: var(--primary);\n    color: white;\n    box-shadow: 0 4px 6px -1px rgba(99, 102, 241, 0.2), 0 2px 4px -2px rgba(99, 102, 241, 0.1);\n}\n\n.btn-primary:hover {\n    background: var(--secondary);\n    transform: translateY(-2px);\n    box-shadow: 0 10px 15px -3px rgba(99, 102, 241, 0.3), 0 4px 6px -4px rgba(99, 102, 241, 0.1);\n}\n\n.btn-secondary {\n    background: linear-gradient(135deg, var(--secondary), var(--accent));\n    color: white;\n    box-shadow: 0 4px 15px rgba(0, 78, 137, 0.3);\n}\n\n.btn-success {\n    background: linear-gradient(135deg, var(--success), #27AE60);\n    color: white;\n    box-shadow: 0 4px 15px rgba(46, 204, 113, 0.3);\n}\n\n.btn-warning {\n    background: linear-gradient(135deg, #FFC107, #FFD54F);\n    color: var(--text);\n    font-weight: 700;\n    box-shadow: 0 4px 15px rgba(255, 193, 7, 0.3);\n}\n\n.btn-outline-primary {\n    border: 2px solid var(--primary);\n    color: var(--primary);\n    background: transparent;\n}\n\n.btn-outline-primary:hover {\n    background: var(--primary);\n    color: white;\n    transform: translateY(-2px);\n}\n\n/* Card Styles */\n.card {\n    border: none;\n    border-radius: var(--border-radius);\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);\n    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n    overflow: hidden;\n    background: var(--white);\n    position: relative;\n}\n\n.card:hover {\n    transform: translateY(-5px);\n    box-shadow: 0 15px 30px rgba(0, 0, 0, 0.12);\n}\n\n.card-header {\n    border: none;\n    font-weight: 600;\n    padding: 1.5rem 2rem;\n    background: var(--background);\n    color: var(--text);\n}\n\n.card-body {\n    padding: 2rem;\n}\n\n.card-gradient {\n    position: relative;\n    overflow: hidden;\n    z-index: 1;\n}\n\n.card-gradient::before {\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 5px;\n    background: var(--gradient-primary);\n    z-index: 2;\n}\n\n.card-accent {\n    border-left: 4px solid var(--accent);\n}\n\n.card-primary {\n    border-left: 4px solid var(--primary);\n}\n\n.card-secondary {\n    border-left: 4px solid var(--secondary);\n}\n\n.card-success {\n    border-left: 4px solid var(--success);\n}\n\n.card-dashboard {\n    height: 100%;\n    display: flex;\n    flex-direction: column;\n}\n\n.card-dashboard .card-body {\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n}\n\n.card-stat {\n    text-align: center;\n    padding: 1.5rem;\n}\n\n.stat-value {\n    font-size: 2.5rem;\n    font-weight: 700;\n    color: var(--primary);\n    margin-bottom: 0.5rem;\n}\n\n.stat-label {\n    font-size: 0.9rem;\n    color: var(--text);\n    opacity: 0.8;\n}\n\n/* Form Styles */\n.form-control {\n    border-radius: var(--border-radius);\n    border: 1px solid var(--border-light);\n    padding: 0.75rem 1rem;\n    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n    background: var(--white);\n    font-size: 0.95rem;\n    color: var(--text);\n    line-height: 1.5;\n    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);\n}\n\n.form-control:hover {\n    border-color: var(--accent);\n}\n\n.form-control:focus {\n    border-color: var(--primary);\n    box-shadow: 0 0 0 3px rgba(255, 107, 53, 0.2);\n    background: var(--white);\n    outline: none;\n    transform: translateY(-1px);\n}\n\n.form-select {\n    border-radius: var(--border-radius);\n    border: 1px solid var(--border-light);\n    padding: 0.75rem 1rem;\n    background: var(--white);\n    font-size: 0.95rem;\n    color: var(--text);\n    background-image: url(\"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='%23FF6B35'%3e%3cpath fill-rule='evenodd' d='M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z' clip-rule='evenodd'/%3e%3c/svg%3e\");\n    background-position: right 0.75rem center;\n    background-size: 1.25rem;\n    background-repeat: no-repeat;\n    padding-right: 2.5rem;\n    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);\n    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n}\n\n.form-select:focus {\n    border-color: var(--primary);\n    box-shadow: 0 0 0 3px rgba(255, 107, 53, 0.2);\n    outline: none;\n}\n\n.form-label {\n    font-weight: 600;\n    color: var(--text);\n    margin-bottom: 0.5rem;\n    font-size: 0.95rem;\n    font-family: 'Montserrat', sans-serif;\n}\n\n.input-group-text {\n    border-radius: var(--border-radius) 0 0 var(--border-radius);\n    border: 1px solid var(--border-light);\n    border-right: none;\n    background: var(--white);\n    color: var(--text);\n    font-size: 0.95rem;\n}\n\n/* Authentication Forms */\n.auth-form {\n    max-width: 450px;\n    margin: 0 auto;\n    padding: 2rem;\n}\n\n.auth-title {\n    text-align: center;\n    margin-bottom: 2rem;\n    color: var(--secondary);\n}\n\n.auth-subtitle {\n    text-align: center;\n    margin-bottom: 2rem;\n    color: var(--text);\n    opacity: 0.8;\n    font-size: 1rem;\n}\n\n.auth-form .form-group {\n    margin-bottom: 1.5rem;\n}\n\n.auth-form .btn {\n    width: 100%;\n    padding: 0.75rem;\n    font-weight: 600;\n    margin-top: 1rem;\n}\n\n.auth-form .form-text {\n    text-align: center;\n    margin-top: 1.5rem;\n    color: var(--text);\n    opacity: 0.8;\n}\n\n.auth-form .form-text a {\n    color: var(--primary);\n    text-decoration: none;\n    font-weight: 600;\n}\n\n.auth-form .form-text a:hover {\n    text-decoration: underline;\n}\n\n/* 3D Scrolling Effects */\n.parallax-container {\n    perspective: 1500px;\n    transform-style: preserve-3d;\n    overflow: hidden;\n    height: 100vh;\n    position: relative;\n}\n\n.parallax-element {\n    transform-style: preserve-3d;\n    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n    will-change: transform;\n}\n\n.parallax-layer {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    transform-style: preserve-3d;\n}\n\n.parallax-layer-0 { transform: translateZ(0); }\n.parallax-layer-1 { transform: translateZ(-100px); }\n.parallax-layer-2 { transform: translateZ(-200px); }\n.parallax-layer-3 { transform: translateZ(-300px); }\n.parallax-layer-4 { transform: translateZ(-400px); }\n\n/* Hero Section 3D Effects */\n.hero-3d {\n    position: relative;\n    overflow: hidden;\n    transform-style: preserve-3d;\n    min-height: 100vh;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.floating-shapes {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    pointer-events: none;\n    transform-style: preserve-3d;\n}\n\n.shape {\n    position: absolute;\n    border-radius: 50%;\n    background: linear-gradient(45deg, var(--primary), var(--accent));\n    opacity: 0.7;\n    animation: float 8s infinite ease-in-out;\n}\n\n.shape:nth-child(1) {\n    width: 200px;\n    height: 200px;\n    top: 10%;\n    left: 10%;\n    animation-delay: 0s;\n}\n\n.shape:nth-child(2) {\n    width: 150px;\n    height: 150px;\n    top: 60%;\n    right: 15%;\n    animation-delay: -2s;\n}\n\n.shape:nth-child(3) {\n    width: 100px;\n    height: 100px;\n    bottom: 20%;\n    left: 60%;\n    animation-delay: -4s;\n}\n\n@keyframes float {\n    0%, 100% { transform: translateY(0) translateZ(0); }\n    50% { transform: translateY(-20px) translateZ(50px); }\n}\n\n.shape:nth-child(1) {\n    width: 200px;\n    height: 200px;\n    top: 10%;\n    left: 10%;\n    animation-delay: 0s;\n}\n\n.shape:nth-child(2) {\n    width: 150px;\n    height: 150px;\n    top: 60%;\n    right: 15%;\n    animation-delay: -2s;\n}\n\n.shape:nth-child(3) {\n    width: 100px;\n    height: 100px;\n    bottom: 20%;\n    left: 60%;\n    animation-delay: -4s;\n}\n\n@keyframes float3d {\n    0%, 100% {\n        transform: translateY(0px) rotateX(0deg) rotateY(0deg);\n    }\n    33% {\n        transform: translateY(-30px) rotateX(15deg) rotateY(5deg);\n    }\n    66% {\n        transform: translateY(-15px) rotateX(-10deg) rotateY(-5deg);\n    }\n}\n\n/* 3D Card Effects */\n.card-3d {\n    transform-style: preserve-3d;\n    transition: transform 0.3s ease;\n}\n\n.card-3d:hover {\n    transform: rotateX(5deg) rotateY(5deg) translateZ(20px);\n}\n\n/* Loading Animations */\n.loading-spinner {\n    display: inline-block;\n    width: 40px;\n    height: 40px;\n    border: 4px solid rgba(255, 107, 53, 0.3);\n    border-radius: 50%;\n    border-top-color: var(--primary);\n    animation: spin 1s ease-in-out infinite;\n}\n\n@keyframes spin {\n    to {\n        transform: rotate(360deg);\n    }\n}\n\n/* Gradient Text */\n.gradient-text {\n    background: linear-gradient(135deg, var(--primary), var(--secondary));\n    -webkit-background-clip: text;\n    -webkit-text-fill-color: transparent;\n    font-weight: 600;\n    letter-spacing: -0.025em;\n    background-clip: text;\n}\n\n/* Stats Animation */\n.stat-counter {\n    font-family: 'Montserrat', sans-serif;\n    font-weight: 800;\n    font-size: 3rem;\n    background: linear-gradient(135deg, var(--primary), var(--accent));\n    -webkit-background-clip: text;\n    -webkit-text-fill-color: transparent;\n    background-clip: text;\n}\n\n/* Progress Bars */\n.progress {\n    height: 12px;\n    border-radius: 10px;\n    background: var(--light-gray);\n    overflow: hidden;\n    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.progress-bar {\n    background: linear-gradient(90deg, var(--primary), var(--accent));\n    border-radius: 10px;\n    transition: width 0.6s ease;\n    position: relative;\n}\n\n.progress-bar::after {\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);\n    animation: shimmer 2s infinite;\n}\n\n@keyframes shimmer {\n    0% {\n        transform: translateX(-100%);\n    }\n    100% {\n        transform: translateX(100%);\n    }\n}\n\n/* Badge Styles */\n.badge {\n    font-weight: 600;\n    border-radius: 20px;\n    padding: 0.5rem 1rem;\n}\n\n/* Alert Styles */\n.alert {\n    border: 1px solid var(--border-light);\n    border-radius: var(--border-radius);\n    padding: 1rem 1.25rem;\n    box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);\n}\n\n.alert-info {\n    background: rgba(129, 140, 248, 0.1);\n    color: var(--secondary);\n    border-left: 3px solid var(--accent);\n}\n\n.alert-success {\n    background: rgba(52, 211, 153, 0.1);\n    color: #059669;\n    border-left: 3px solid var(--success);\n}\n\n/* Modal Enhancements */\n.modal-content {\n    border: none;\n    border-radius: 20px;\n    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);\n}\n\n.modal-header {\n    border: none;\n    padding: 2rem 2rem 1rem;\n}\n\n.modal-body {\n    padding: 1rem 2rem;\n}\n\n.modal-footer {\n    border: none;\n    padding: 1rem 2rem 2rem;\n}\n\n/* Table Styles */\n.table {\n    width: 100%;\n    margin-bottom: 1rem;\n    color: var(--text);\n    vertical-align: top;\n    border-color: var(--border-light);\n    border-radius: var(--border-radius);\n    overflow: hidden;\n    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);\n}\n\n.table > :not(caption) > * > * {\n    padding: 1rem;\n    background-color: var(--white);\n    border-bottom: 1px solid var(--border-light);\n    font-size: 0.95rem;\n    transition: background-color 0.2s ease;\n}\n\n.table > tbody > tr:hover > * {\n    background-color: var(--light-gray);\n}\n\n.table > thead > tr > th {\n    background: linear-gradient(135deg, var(--secondary), var(--accent));\n    color: white;\n    font-weight: 600;\n    text-transform: uppercase;\n    font-size: 0.85rem;\n    letter-spacing: 0.05em;\n    padding: 0.75rem 1rem;\n    white-space: nowrap;\n}\n\n.table-striped > tbody > tr:nth-of-type(odd) > * {\n    background-color: var(--background);\n}\n\n.table-striped > tbody > tr:hover > * {\n    background-color: var(--light-gray);\n}\n\n/* Responsive Design */\n@media (max-width: 768px) {\n    .btn {\n        padding: 0.6rem 1.5rem;\n        font-size: 0.9rem;\n    }\n\n    .card-body {\n        padding: 1.5rem;\n    }\n\n    .hero-section h1 {\n        font-size: 2.5rem;\n    }\n\n    .stat-counter {\n        font-size: 2rem;\n    }\n}\n\n@media (max-width: 576px) {\n    .container-fluid {\n        padding: 0 1rem;\n    }\n\n    .card {\n        margin: 0.5rem;\n    }\n\n    .btn {\n        font-size: 0.85rem;\n        padding: 0.5rem 1.25rem;\n    }\n}\n\n/* Animation Classes */\n.fade-in {\n    animation: fadeIn 0.6s ease-in-out;\n}\n\n@keyframes fadeIn {\n    from {\n        opacity: 0;\n        transform: translateY(10px);\n    }\n    to {\n        opacity: 1;\n        transform: translateY(0);\n    }\n}\n\n.slide-in-left {\n    animation: slideInLeft 0.6s ease-out;\n}\n\n@keyframes slideInLeft {\n    from {\n        opacity: 0;\n        transform: translateX(-50px);\n    }\n    to {\n        opacity: 1;\n        transform: translateX(0);\n    }\n}\n\n.slide-in-right {\n    animation: slideInRight 0.6s ease-out;\n}\n\n@keyframes slideInRight {\n    from {\n        opacity: 0;\n        transform: translateX(50px);\n    }\n    to {\n        opacity: 1;\n        transform: translateX(0);\n    }\n}\n\n.bounce-in {\n    animation: bounceIn 0.8s ease-out;\n}\n\n@keyframes bounceIn {\n    0% {\n        opacity: 0;\n        transform: scale(0.3);\n    }\n    50% {\n        opacity: 1;\n        transform: scale(1.05);\n    }\n    70% {\n        transform: scale(0.9);\n    }\n    100% {\n        opacity: 1;\n        transform: scale(1);\n    }\n}\n\n/* Utility Classes */\n.text-primary {\n    color: var(--primary) !important;\n}\n\n.text-secondary {\n    color: var(--secondary) !important;\n}\n\n.bg-primary {\n    background: linear-gradient(135deg, var(--primary), #FF8E53) !important;\n}\n\n.bg-secondary {\n    background: linear-gradient(135deg, var(--secondary), var(--accent)) !important;\n}\n\n.shadow-sm {\n    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08) !important;\n}\n\n.shadow {\n    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.12) !important;\n}\n\n.shadow-lg {\n    box-shadow: 0 15px 35px rgba(0, 0, 0, 0.15) !important;\n}\n\n/* Camera Feed Styles */\n.camera-container {\n    position: relative;\n    background: #000;\n    border-radius: 15px;\n    overflow: hidden;\n}\n\n.camera-overlay {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    pointer-events: none;\n    z-index: 10;\n}\n\n.pose-points {\n    position: absolute;\n    width: 8px;\n    height: 8px;\n    background: var(--primary);\n    border-radius: 50%;\n    border: 2px solid white;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);\n}\n\n.pose-connection {\n    position: absolute;\n    background: var(--primary);\n    height: 2px;\n    transform-origin: left center;\n}\n\n/* Dashboard Styles */\n.dashboard-container {\n    padding: 2rem 0;\n}\n\n.dashboard-header {\n    margin-bottom: 2rem;\n}\n\n.dashboard-title {\n    font-weight: 700;\n    margin-bottom: 0.5rem;\n    color: var(--secondary);\n    font-family: 'Montserrat', sans-serif;\n}\n\n.dashboard-subtitle {\n    color: var(--text);\n    opacity: 0.8;\n    font-size: 1.1rem;\n}\n\n/* Dashboard Widgets */\n.widget-container {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));\n    gap: 1.5rem;\n    margin-bottom: 2rem;\n}\n\n.widget {\n    background: var(--white);\n    border-radius: var(--border-radius);\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);\n    overflow: hidden;\n    transition: all 0.3s ease;\n    height: 100%;\n    display: flex;\n    flex-direction: column;\n}\n\n.widget-header {\n    padding: 1.25rem;\n    border-bottom: 1px solid rgba(0, 0, 0, 0.05);\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n}\n\n.widget-title {\n    font-weight: 600;\n    font-size: 1rem;\n    margin: 0;\n    color: var(--text);\n}\n\n.widget-body {\n    padding: 1.25rem;\n    flex: 1;\n}\n\n.widget-footer {\n    padding: 1rem 1.25rem;\n    border-top: 1px solid rgba(0, 0, 0, 0.05);\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background-color: rgba(0, 0, 0, 0.02);\n}\n\n.widget-metric {\n    text-align: center;\n    padding: 1.5rem;\n}\n\n.metric-value {\n    font-size: 2.5rem;\n    font-weight: 700;\n    color: var(--primary);\n    margin-bottom: 0.5rem;\n    line-height: 1;\n}\n\n.metric-label {\n    font-size: 0.9rem;\n    color: var(--text);\n    opacity: 0.8;\n}\n\n.widget-chart {\n    height: 200px;\n    width: 100%;\n}\n\n.widget-camera {\n    position: relative;\n    overflow: hidden;\n    border-radius: var(--border-radius);\n    background: #000;\n    aspect-ratio: 16/9;\n}\n\n.widget-camera video {\n    width: 100%;\n    height: 100%;\n    object-fit: cover;\n}\n\n.camera-overlay {\n    position: absolute;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    padding: 1rem;\n    background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);\n    color: white;\n    font-weight: 500;\n}\n\n.widget-list {\n    list-style: none;\n    padding: 0;\n    margin: 0;\n}\n\n.widget-list-item {\n    padding: 0.75rem 0;\n    border-bottom: 1px solid rgba(0, 0, 0, 0.05);\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n}\n\n.widget-list-item:last-child {\n    border-bottom: none;\n}\n\n.widget-progress {\n    height: 8px;\n    background: rgba(0, 0, 0, 0.05);\n    border-radius: 4px;\n    overflow: hidden;\n    margin: 0.5rem 0;\n}\n\n.widget-progress-bar {\n    height: 100%;\n    background: var(--gradient-primary);\n    border-radius: 4px;\n    transition: width 0.3s ease;\n}\n\n/* Responsive Dashboard */\n@media (max-width: 768px) {\n    .widget-container {\n        grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));\n    }\n\n    .widget-header, .widget-body, .widget-footer {\n        padding: 1rem;\n    }\n\n    .metric-value {\n        font-size: 2rem;\n    }\n}\n\n@media (max-width: 576px) {\n    .widget-container {\n        grid-template-columns: 1fr;\n    }\n\n    .dashboard-title {\n        font-size: 1.75rem;\n    }\n\n    .dashboard-subtitle {\n        font-size: 1rem;\n    }\n}\n\n/* Food Analyzer Styles */\n.upload-zone {\n    border: 3px dashed var(--primary);\n    border-radius: 20px;\n    padding: 3rem;\n    text-align: center;\n    transition: all 0.3s ease;\n    background: rgba(255, 107, 53, 0.05);\n}\n\n.upload-zone:hover,\n.upload-zone.dragover {\n    border-color: var(--accent);\n    background: rgba(0, 168, 204, 0.1);\n    transform: scale(1.02);\n}\n\n.upload-zone.uploading {\n    border-color: var(--success);\n    background: rgba(46, 204, 113, 0.1);\n}\n\n/* Workout Planner Styles */\n.exercise-card {\n    border-left: 4px solid var(--primary);\n    transition: all 0.3s ease;\n}\n\n.exercise-card:hover {\n    border-left-color: var(--accent);\n    background: rgba(0, 168, 204, 0.05);\n}\n\n.difficulty-badge {\n    position: absolute;\n    top: 1rem;\n    right: 1rem;\n    padding: 0.25rem 0.75rem;\n    border-radius: 20px;\n    font-size: 0.75rem;\n    font-weight: 600;\n}\n\n.difficulty-beginner {\n    background: rgba(46, 204, 113, 0.2);\n    color: var(--success);\n}\n\n.difficulty-intermediate {\n    background: rgba(255, 193, 7, 0.2);\n    color: #F39C12;\n}\n\n.difficulty-advanced {\n    background: rgba(231, 76, 60, 0.2);\n    color: #E74C3C;\n}\n\n/* Chat Interface */\n.chat-container {\n    max-height: 400px;\n    overflow-y: auto;\n    padding: 1rem;\n    background: var(--light-gray);\n    border-radius: 15px;\n}\n\n.chat-message {\n    margin-bottom: 1rem;\n    display: flex;\n    align-items: flex-start;\n}\n\n.chat-message.user {\n    justify-content: flex-end;\n}\n\n.chat-bubble {\n    max-width: 70%;\n    padding: 0.75rem 1rem;\n    border-radius: 20px;\n    font-size: 0.9rem;\n    line-height: 1.4;\n}\n\n.chat-bubble.user {\n    background: linear-gradient(135deg, var(--primary), #FF8E53);\n    color: white;\n    border-bottom-right-radius: 5px;\n}\n\n.chat-bubble.ai {\n    background: white;\n    color: var(--text);\n    border: 1px solid var(--border-light);\n    border-bottom-left-radius: 5px;\n}\n\n/* Success States */\n.success-animation {\n    animation: successPulse 0.6s ease-out;\n}\n\n@keyframes successPulse {\n    0% {\n        transform: scale(1);\n        box-shadow: 0 0 0 0 rgba(46, 204, 113, 0.7);\n    }\n    70% {\n        transform: scale(1.05);\n        box-shadow: 0 0 0 10px rgba(46, 204, 113, 0);\n    }\n    100% {\n        transform: scale(1);\n        box-shadow: 0 0 0 0 rgba(46, 204, 113, 0);\n    }\n}\n\n/* Error States */\n.error-shake {\n    animation: errorShake 0.5s ease-in-out;\n}\n\n@keyframes errorShake {\n    0%, 100% {\n        transform: translateX(0);\n    }\n    10%, 30%, 50%, 70%, 90% {\n        transform: translateX(-5px);\n    }\n    20%, 40%, 60%, 80% {\n        transform: translateX(5px);\n    }\n}\n\n/* Print Styles */\n@media print {\n    .navbar,\n    .btn,\n    .modal,\n    .floating-shapes {\n        display: none !important;\n    }\n\n    .card {\n        box-shadow: none !important;\n        border: 1px solid #ddd !important;\n    }\n\n    body {\n        background: white !important;\n        color: black !important;\n    }\n}\n","size_bytes":25663},"static/js/dashboard.js":{"content":"/**\n * VisionFit AI - Dashboard\n * Interactive dashboard with charts and AI companion\n */\n\nclass DashboardManager {\n    constructor() {\n        this.charts = {};\n        this.chatHistory = [];\n        this.isLoading = false;\n\n        this.init();\n    }\n\n    async init() {\n        try {\n            await this.loadDashboardData();\n            this.initializeCharts();\n            this.setupChatInterface();\n            this.setupEventListeners();\n            this.startLiveUpdates();\n\n            console.log('Dashboard initialized successfully');\n        } catch (error) {\n            console.error('Dashboard initialization failed:', error);\n            VisionFit.utils.showToast('Failed to load dashboard data', 'danger');\n        }\n    }\n\n    async loadDashboardData() {\n        try {\n            const response = await VisionFit.api.get('/dashboard-stats');\n\n            if (response.success) {\n                this.dashboardData = response.data;\n                this.updateStatCards();\n            } else {\n                throw new Error(response.error || 'Failed to load dashboard data');\n            }\n        } catch (error) {\n            console.error('Failed to load dashboard data:', error);\n            // Use mock data for demonstration\n            this.dashboardData = this.generateMockData();\n            this.updateStatCards();\n        }\n    }\n\n    generateMockData() {\n        const dates = [];\n        const calories = [];\n        const workouts = [];\n\n        // Generate data for last 30 days\n        for (let i = 29; i >= 0; i--) {\n            const date = new Date();\n            date.setDate(date.getDate() - i);\n            dates.push(date.toISOString().split('T')[0]);\n\n            // Random workout data\n            if (Math.random() > 0.4) { // 60% chance of workout\n                calories.push(Math.floor(Math.random() * 300) + 200);\n                workouts.push(1);\n            } else {\n                calories.push(0);\n                workouts.push(0);\n            }\n        }\n\n        return {\n            workout_dates: dates,\n            calories_burned: calories,\n            total_workouts: workouts.reduce((sum, w) => sum + w, 0),\n            avg_calories: Math.round(calories.reduce((sum, c) => sum + c, 0) / calories.length)\n        };\n    }\n\n    updateStatCards() {\n        // No workout stats to update\n        return;\n\n        if (avgDurationCard) {\n            avgDurationCard.textContent = '25 min'; // Mock average\n        }\n\n        // Update sidebar stats\n        const weeklyWorkouts = document.getElementById('weeklyWorkouts');\n        if (weeklyWorkouts) {\n            const recentWorkouts = this.dashboardData.calories_burned.slice(-7).filter(c => c > 0).length;\n            weeklyWorkouts.textContent = recentWorkouts;\n        }\n    }\n\n    initializeCharts() {\n        this.createWorkoutProgressChart();\n        this.createExerciseDistributionChart();\n    }\n\n    createWorkoutProgressChart() {\n        const ctx = document.getElementById('workoutChart');\n        if (!ctx) return;\n\n        // Prepare data for last 14 days\n        const dates = this.dashboardData.workout_dates.slice(-14);\n        const calories = this.dashboardData.calories_burned.slice(-14);\n\n        const labels = dates.map(date => {\n            const d = new Date(date);\n            return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });\n        });\n\n        this.charts.workoutProgress = new Chart(ctx, {\n            type: 'line',\n            data: {\n                labels: labels,\n                datasets: [{\n                    label: 'Calories Burned',\n                    data: calories,\n                    borderColor: '#FF6B35',\n                    backgroundColor: 'rgba(255, 107, 53, 0.1)',\n                    borderWidth: 3,\n                    fill: true,\n                    tension: 0.4,\n                    pointBackgroundColor: '#FF6B35',\n                    pointBorderColor: '#ffffff',\n                    pointBorderWidth: 2,\n                    pointRadius: 6,\n                    pointHoverRadius: 8\n                }]\n            },\n            options: {\n                responsive: true,\n                maintainAspectRatio: false,\n                plugins: {\n                    legend: {\n                        display: false\n                    },\n                    tooltip: {\n                        mode: 'index',\n                        intersect: false,\n                        backgroundColor: 'rgba(44, 62, 80, 0.9)',\n                        titleColor: '#ffffff',\n                        bodyColor: '#ffffff',\n                        borderColor: '#FF6B35',\n                        borderWidth: 1,\n                        cornerRadius: 8,\n                        padding: 12\n                    }\n                },\n                scales: {\n                    x: {\n                        grid: {\n                            display: false\n                        },\n                        ticks: {\n                            color: '#6c757d'\n                        }\n                    },\n                    y: {\n                        beginAtZero: true,\n                        grid: {\n                            color: 'rgba(0, 0, 0, 0.05)'\n                        },\n                        ticks: {\n                            color: '#6c757d',\n                            callback: function(value) {\n                                return value + ' cal';\n                            }\n                        }\n                    }\n                },\n                interaction: {\n                    intersect: false,\n                    mode: 'index'\n                },\n                elements: {\n                    point: {\n                        hoverBackgroundColor: '#FF6B35',\n                        hoverBorderColor: '#ffffff'\n                    }\n                }\n            }\n        });\n    }\n\n    createExerciseDistributionChart() {\n        const ctx = document.getElementById('exerciseChart');\n        if (!ctx) return;\n\n        // Mock exercise distribution data\n        const exerciseData = {\n            'Push-ups': 35,\n            'Squats': 30,\n            'Jumping Jacks': 20,\n            'Others': 15\n        };\n\n        this.charts.exerciseDistribution = new Chart(ctx, {\n            type: 'doughnut',\n            data: {\n                labels: Object.keys(exerciseData),\n                datasets: [{\n                    data: Object.values(exerciseData),\n                    backgroundColor: [\n                        '#FF6B35',\n                        '#004E89',\n                        '#00A8CC',\n                        '#2ECC71'\n                    ],\n                    borderWidth: 3,\n                    borderColor: '#ffffff',\n                    hoverBorderWidth: 4,\n                    hoverBorderColor: '#ffffff'\n                }]\n            },\n            options: {\n                responsive: true,\n                maintainAspectRatio: false,\n                plugins: {\n                    legend: {\n                        position: 'bottom',\n                        labels: {\n                            padding: 20,\n                            usePointStyle: true,\n                            font: {\n                                size: 12,\n                                weight: '600'\n                            }\n                        }\n                    },\n                    tooltip: {\n                        backgroundColor: 'rgba(44, 62, 80, 0.9)',\n                        titleColor: '#ffffff',\n                        bodyColor: '#ffffff',\n                        borderColor: '#FF6B35',\n                        borderWidth: 1,\n                        cornerRadius: 8,\n                        padding: 12,\n                        callbacks: {\n                            label: function(context) {\n                                return context.label + ': ' + context.parsed + '%';\n                            }\n                        }\n                    }\n                },\n                cutout: '60%',\n                animation: {\n                    animateRotate: true,\n                    animateScale: true,\n                    duration: 1000,\n                    easing: 'easeOutQuart'\n                }\n            }\n        });\n    }\n\n    setupChatInterface() {\n        const chatInput = document.getElementById('chatInput');\n        const sendBtn = document.getElementById('sendChat');\n\n        if (chatInput && sendBtn) {\n            // Send message on button click\n            sendBtn.addEventListener('click', () => this.sendChatMessage());\n\n            // Send message on Enter key\n            chatInput.addEventListener('keypress', (e) => {\n                if (e.key === 'Enter' && !e.shiftKey) {\n                    e.preventDefault();\n                    this.sendChatMessage();\n                }\n            });\n        }\n    }\n\n    async sendChatMessage() {\n        const chatInput = document.getElementById('chatInput');\n        const message = chatInput.value.trim();\n\n        if (!message || this.isLoading) return;\n\n        // Clear input and show loading\n        chatInput.value = '';\n        this.isLoading = true;\n\n        // Add user message to chat\n        this.addChatMessage(message, 'user');\n\n        try {\n            // Show typing indicator\n            this.showTypingIndicator();\n\n            // Send to AI\n            const response = await VisionFit.api.post('/fitness-chat', { question: message });\n\n            // Remove typing indicator\n            this.hideTypingIndicator();\n\n            if (response.success) {\n                this.addChatMessage(response.response, 'ai');\n            } else {\n                throw new Error(response.error || 'Failed to get response');\n            }\n\n        } catch (error) {\n            console.error('Chat error:', error);\n            this.hideTypingIndicator();\n            this.addChatMessage('Sorry, I encountered an error. Please try again.', 'ai');\n        } finally {\n            this.isLoading = false;\n        }\n    }\n\n    addChatMessage(message, sender) {\n        const chatContainer = document.getElementById('chatMessages');\n        if (!chatContainer) return;\n\n        const messageElement = document.createElement('div');\n        messageElement.className = `chat-message ${sender} mb-2`;\n\n        if (sender === 'user') {\n            messageElement.innerHTML = `\n                <div class=\"chat-bubble user ms-auto\">\n                    ${this.escapeHtml(message)}\n                </div>\n            `;\n        } else {\n            messageElement.innerHTML = `\n                <div class=\"chat-bubble ai\">\n                    <strong>VisionFit AI:</strong><br>\n                    ${this.escapeHtml(message)}\n                </div>\n            `;\n        }\n\n        chatContainer.appendChild(messageElement);\n        chatContainer.scrollTop = chatContainer.scrollHeight;\n\n        // Add fade-in animation\n        messageElement.style.opacity = '0';\n        messageElement.style.transform = 'translateY(20px)';\n\n        requestAnimationFrame(() => {\n            messageElement.style.transition = 'all 0.3s ease';\n            messageElement.style.opacity = '1';\n            messageElement.style.transform = 'translateY(0)';\n        });\n\n        // Store in history\n        this.chatHistory.push({ message, sender, timestamp: new Date() });\n    }\n\n    showTypingIndicator() {\n        const chatContainer = document.getElementById('chatMessages');\n        if (!chatContainer) return;\n\n        const typingElement = document.createElement('div');\n        typingElement.className = 'chat-message ai mb-2 typing-indicator';\n        typingElement.innerHTML = `\n            <div class=\"chat-bubble ai\">\n                <div class=\"typing-dots\">\n                    <span></span>\n                    <span></span>\n                    <span></span>\n                </div>\n            </div>\n        `;\n\n        chatContainer.appendChild(typingElement);\n        chatContainer.scrollTop = chatContainer.scrollHeight;\n\n        // Add CSS for typing animation\n        const style = document.createElement('style');\n        style.textContent = `\n            .typing-dots {\n                display: flex;\n                gap: 4px;\n                align-items: center;\n            }\n            .typing-dots span {\n                width: 6px;\n                height: 6px;\n                background: #6c757d;\n                border-radius: 50%;\n                animation: typing 1.4s infinite ease-in-out;\n            }\n            .typing-dots span:nth-child(1) { animation-delay: -0.32s; }\n            .typing-dots span:nth-child(2) { animation-delay: -0.16s; }\n            @keyframes typing {\n                0%, 80%, 100% { transform: scale(0.8); opacity: 0.5; }\n                40% { transform: scale(1); opacity: 1; }\n            }\n        `;\n        if (!document.querySelector('style[data-typing]')) {\n            style.setAttribute('data-typing', 'true');\n            document.head.appendChild(style);\n        }\n    }\n\n    hideTypingIndicator() {\n        const typingIndicator = document.querySelector('.typing-indicator');\n        if (typingIndicator) {\n            typingIndicator.remove();\n        }\n    }\n\n    escapeHtml(text) {\n        const div = document.createElement('div');\n        div.textContent = text;\n        return div.innerHTML;\n    }\n\n    setupEventListeners() {\n        // Refresh data button (if exists)\n        const refreshBtn = document.querySelector('[data-action=\"refresh\"]');\n        if (refreshBtn) {\n            refreshBtn.addEventListener('click', () => this.refreshDashboard());\n        }\n\n        // Export data button (if exists)\n        const exportBtn = document.querySelector('[data-action=\"export\"]');\n        if (exportBtn) {\n            exportBtn.addEventListener('click', () => this.exportData());\n        }\n\n        // Listen for window resize to update charts\n        window.addEventListener('visionfit:resize', () => {\n            Object.values(this.charts).forEach(chart => {\n                if (chart && typeof chart.resize === 'function') {\n                    chart.resize();\n                }\n            });\n        });\n    }\n\n    startLiveUpdates() {\n        // Update every 30 seconds\n        this.updateInterval = setInterval(() => {\n            this.updateLiveData();\n        }, 30000);\n    }\n\n    async updateLiveData() {\n        try {\n            // Update workout duration if timer is running\n            const workoutTimer = VisionFit.components.timer.getElapsed('workout');\n            if (workoutTimer > 0) {\n                const duration = VisionFit.components.timer.formatTime(workoutTimer);\n                document.getElementById('workoutDuration').textContent = duration;\n            }\n\n            // Refresh dashboard data periodically\n            if (Math.random() > 0.8) { // 20% chance every 30 seconds\n                await this.loadDashboardData();\n                this.updateCharts();\n            }\n\n        } catch (error) {\n            console.error('Live update error:', error);\n        }\n    }\n\n    updateCharts() {\n        // No workout charts to update\n        return;\n    }\n\n    async refreshDashboard() {\n        const refreshBtn = document.querySelector('[data-action=\"refresh\"]');\n        if (refreshBtn) {\n            const originalText = refreshBtn.innerHTML;\n            refreshBtn.innerHTML = '<i class=\"fas fa-spinner fa-spin\"></i>';\n            refreshBtn.disabled = true;\n        }\n\n        try {\n            await this.loadDashboardData();\n            this.updateCharts();\n            VisionFit.utils.showToast('Dashboard refreshed', 'success');\n        } catch (error) {\n            VisionFit.utils.showToast('Failed to refresh dashboard', 'danger');\n        } finally {\n            if (refreshBtn) {\n                refreshBtn.innerHTML = '<i class=\"fas fa-sync-alt\"></i>';\n                refreshBtn.disabled = false;\n            }\n        }\n    }\n\n    exportData() {\n        try {\n            const exportData = {\n                stats: this.dashboardData,\n                chatHistory: this.chatHistory,\n                exportDate: new Date().toISOString()\n            };\n\n            const dataStr = JSON.stringify(exportData, null, 2);\n            const dataBlob = new Blob([dataStr], { type: 'application/json' });\n\n            const link = document.createElement('a');\n            link.href = URL.createObjectURL(dataBlob);\n            link.download = `visionfit-data-${new Date().toISOString().split('T')[0]}.json`;\n            link.click();\n\n            VisionFit.utils.showToast('Data exported successfully', 'success');\n        } catch (error) {\n            console.error('Export error:', error);\n            VisionFit.utils.showToast('Failed to export data', 'danger');\n        }\n    }\n\n    destroy() {\n        // Clean up intervals and event listeners\n        if (this.updateInterval) {\n            clearInterval(this.updateInterval);\n        }\n\n        // Destroy charts\n        Object.values(this.charts).forEach(chart => {\n            if (chart && typeof chart.destroy === 'function') {\n                chart.destroy();\n            }\n        });\n    }\n}\n\n// Initialize dashboard when DOM is ready\ndocument.addEventListener('DOMContentLoaded', function() {\n    // Check if we're on the dashboard page\n    if (document.getElementById('workoutChart')) {\n        window.dashboardManager = new DashboardManager();\n    }\n});\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', function() {\n    if (window.dashboardManager) {\n        window.dashboardManager.destroy();\n    }\n});\n","size_bytes":17657},"static/js/exercise_analysis.js":{"content":"// VisionFit AI - Exercise Analysis with MediaPipe Pose\n\nclass ExerciseAnalyzer {\n    constructor() {\n        // MediaPipe components\n        this.pose = null;\n        this.camera = null;\n\n        // DOM elements\n        this.webcam = document.getElementById('webcam');\n        this.canvas = document.getElementById('output-canvas');\n        this.ctx = this.canvas.getContext('2d');\n        this.startBtn = document.getElementById('start-btn');\n        this.stopBtn = document.getElementById('stop-btn');\n        this.repCount = document.getElementById('rep-count');\n        this.formScoreBar = document.getElementById('form-score-bar');\n        this.feedbackContainer = document.getElementById('feedback-container');\n\n        // Exercise state\n        this.isActive = false;\n        this.exerciseType = 'pushup'; // default exercise\n        this.landmarks = [];\n\n        // Bind methods\n        this.onResults = this.onResults.bind(this);\n        this.start = this.start.bind(this);\n        this.stop = this.stop.bind(this);\n        this.setExerciseType = this.setExerciseType.bind(this);\n        this.analyzePose = this.analyzePose.bind(this);\n\n        // Initialize event listeners\n        this.initEventListeners();\n    }\n\n    async initialize() {\n        try {\n            // Initialize MediaPipe Pose\n            this.pose = new Pose({\n                locateFile: (file) => {\n                    return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;\n                }\n            });\n\n            this.pose.setOptions({\n                modelComplexity: 1,\n                smoothLandmarks: true,\n                enableSegmentation: false,\n                smoothSegmentation: false,\n                minDetectionConfidence: 0.5,\n                minTrackingConfidence: 0.5\n            });\n\n            this.pose.onResults(this.onResults);\n\n            console.log('Exercise analyzer initialized successfully');\n            return true;\n        } catch (error) {\n            console.error('Failed to initialize exercise analyzer:', error);\n            return false;\n        }\n    }\n\n    initEventListeners() {\n        // Start/stop buttons\n        this.startBtn.addEventListener('click', this.start);\n        this.stopBtn.addEventListener('click', this.stop);\n\n        // Exercise type selection\n        const exerciseButtons = document.querySelectorAll('.exercise-type-btn');\n        exerciseButtons.forEach(button => {\n            button.addEventListener('click', () => {\n                exerciseButtons.forEach(btn => btn.classList.remove('active'));\n                button.classList.add('active');\n                this.setExerciseType(button.dataset.exercise);\n            });\n        });\n    }\n\n    setExerciseType(type) {\n        this.exerciseType = type;\n        console.log(`Exercise type set to: ${type}`);\n\n        // Reset stats when changing exercise type\n        this.repCount.textContent = '0';\n        this.formScoreBar.style.width = '0%';\n        this.formScoreBar.textContent = '0%';\n        this.feedbackContainer.innerHTML = `\n            <div class=\"feedback-item\">\n                <i class=\"fas fa-info-circle me-2\"></i>\n                <span>Start exercising to receive feedback</span>\n            </div>\n        `;\n    }\n\n    async start() {\n        try {\n            if (!this.pose) {\n                const initialized = await this.initialize();\n                if (!initialized) {\n                    throw new Error('Failed to initialize pose detector');\n                }\n            }\n\n            // Get camera stream\n            const stream = await navigator.mediaDevices.getUserMedia({\n                video: {\n                    width: { ideal: 1280 },\n                    height: { ideal: 720 },\n                    facingMode: 'user'\n                }\n            });\n\n            this.webcam.srcObject = stream;\n            await this.webcam.play();\n\n            // Set canvas dimensions to match video\n            this.canvas.width = this.webcam.videoWidth;\n            this.canvas.height = this.webcam.videoHeight;\n\n            // Initialize camera\n            this.camera = new Camera(this.webcam, {\n                onFrame: async () => {\n                    if (this.isActive) {\n                        await this.pose.send({ image: this.webcam });\n                    }\n                },\n                width: 1280,\n                height: 720\n            });\n\n            await this.camera.start();\n            this.isActive = true;\n\n            // Update UI\n            this.startBtn.disabled = true;\n            this.stopBtn.disabled = false;\n\n            console.log('Exercise analysis started');\n        } catch (error) {\n            console.error('Failed to start exercise analysis:', error);\n            alert('Failed to access camera. Please ensure you have granted camera permissions.');\n        }\n    }\n\n    stop() {\n        if (this.camera) {\n            this.camera.stop();\n        }\n\n        if (this.webcam.srcObject) {\n            const tracks = this.webcam.srcObject.getTracks();\n            tracks.forEach(track => track.stop());\n            this.webcam.srcObject = null;\n        }\n\n        this.isActive = false;\n\n        // Update UI\n        this.startBtn.disabled = false;\n        this.stopBtn.disabled = true;\n\n        console.log('Exercise analysis stopped');\n    }\n\n    onResults(results) {\n        if (!results || !results.poseLandmarks) {\n            return;\n        }\n\n        // Clear canvas\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n        // Draw pose landmarks\n        this.drawPose(results.poseLandmarks);\n\n        // Convert landmarks to format expected by backend\n        const landmarks = results.poseLandmarks.map(landmark => ({\n            x: landmark.x,\n            y: landmark.y,\n            z: landmark.z,\n            visibility: landmark.visibility\n        }));\n\n        // Send landmarks to backend for analysis\n        this.analyzePose(landmarks);\n    }\n\n    drawPose(landmarks) {\n        // Draw connections\n        this.ctx.lineWidth = 5;\n        this.ctx.strokeStyle = '#00A8CC';\n\n        // Draw pose connections (simplified)\n        const connections = [\n            // Torso\n            [11, 12], [12, 24], [24, 23], [23, 11],\n            // Arms\n            [11, 13], [13, 15], [12, 14], [14, 16],\n            // Legs\n            [23, 25], [25, 27], [24, 26], [26, 28]\n        ];\n\n        connections.forEach(([start, end]) => {\n            const startPoint = landmarks[start];\n            const endPoint = landmarks[end];\n\n            if (startPoint.visibility > 0.5 && endPoint.visibility > 0.5) {\n                this.ctx.beginPath();\n                this.ctx.moveTo(startPoint.x * this.canvas.width, startPoint.y * this.canvas.height);\n                this.ctx.lineTo(endPoint.x * this.canvas.width, endPoint.y * this.canvas.height);\n                this.ctx.stroke();\n            }\n        });\n\n        // Draw landmarks\n        landmarks.forEach((landmark) => {\n            if (landmark.visibility > 0.5) {\n                this.ctx.fillStyle = '#FF6B35';\n                this.ctx.beginPath();\n                this.ctx.arc(\n                    landmark.x * this.canvas.width,\n                    landmark.y * this.canvas.height,\n                    6,\n                    0,\n                    2 * Math.PI\n                );\n                this.ctx.fill();\n            }\n        });\n    }\n\n    async analyzePose(landmarks) {\n        try {\n            const response = await fetch('/api/analyze-pose', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    landmarks: landmarks,\n                    exercise_type: this.exerciseType\n                })\n            });\n\n            if (!response.ok) {\n                throw new Error('Failed to analyze pose');\n            }\n\n            const result = await response.json();\n\n            if (result.error) {\n                console.error('Pose analysis error:', result.error);\n                return;\n            }\n\n            // Update UI with analysis results\n            this.updateStats(result);\n\n        } catch (error) {\n            console.error('Error analyzing pose:', error);\n        }\n    }\n\n    updateStats(result) {\n        // Update rep count\n        this.repCount.textContent = result.reps;\n\n        // Update form score\n        const formScore = result.form_score;\n        this.formScoreBar.style.width = `${formScore}%`;\n        this.formScoreBar.textContent = `${formScore}%`;\n\n        // Set color based on score\n        if (formScore < 50) {\n            this.formScoreBar.className = 'progress-bar bg-danger';\n        } else if (formScore < 80) {\n            this.formScoreBar.className = 'progress-bar bg-warning';\n        } else {\n            this.formScoreBar.className = 'progress-bar bg-success';\n        }\n\n        // Update feedback\n        if (result.feedback && result.feedback.length > 0) {\n            this.feedbackContainer.innerHTML = '';\n\n            result.feedback.forEach(feedback => {\n                const feedbackItem = document.createElement('div');\n                feedbackItem.className = 'feedback-item';\n                feedbackItem.innerHTML = `\n                    <i class=\"fas fa-info-circle me-2\"></i>\n                    <span>${feedback}</span>\n                `;\n                this.feedbackContainer.appendChild(feedbackItem);\n            });\n        }\n    }\n}\n\n// Initialize exercise analyzer when DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n    const exerciseAnalyzer = new ExerciseAnalyzer();\n});","size_bytes":9709},"static/js/main.js":{"content":"/**\n * VisionFit AI - Main JavaScript\n * Common functionality and utilities\n */\n\n// Global app namespace\nwindow.VisionFit = {\n    // App configuration\n    config: {\n        apiBase: '/api',\n        animationDuration: 300,\n        debounceDelay: 500\n    },\n\n    // Utility functions\n    utils: {},\n\n    // Component modules\n    components: {},\n\n    // API helpers\n    api: {}\n};\n\n// Utility Functions\nVisionFit.utils = {\n    /**\n     * Debounce function calls\n     */\n    debounce: function(func, wait) {\n        let timeout;\n        return function executedFunction(...args) {\n            const later = () => {\n                clearTimeout(timeout);\n                func(...args);\n            };\n            clearTimeout(timeout);\n            timeout = setTimeout(later, wait);\n        };\n    },\n\n    /**\n     * Format numbers with locale-specific formatting\n     */\n    formatNumber: function(number) {\n        return new Intl.NumberFormat().format(number);\n    },\n\n    /**\n     * Format duration in minutes to human-readable format\n     */\n    formatDuration: function(minutes) {\n        if (minutes < 60) {\n            return `${minutes} min`;\n        }\n        const hours = Math.floor(minutes / 60);\n        const mins = minutes % 60;\n        return mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;\n    },\n\n    /**\n     * Format date to readable string\n     */\n    formatDate: function(date) {\n        return new Date(date).toLocaleDateString('en-US', {\n            year: 'numeric',\n            month: 'short',\n            day: 'numeric'\n        });\n    },\n\n    /**\n     * Show toast notification\n     */\n    showToast: function(message, type = 'info', duration = 5000) {\n        const toast = document.createElement('div');\n        toast.className = `alert alert-${type} alert-dismissible fade show position-fixed`;\n        toast.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px;';\n\n        toast.innerHTML = `\n            ${message}\n            <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"alert\"></button>\n        `;\n\n        document.body.appendChild(toast);\n\n        // Auto remove after duration\n        setTimeout(() => {\n            if (toast.parentNode) {\n                toast.remove();\n            }\n        }, duration);\n    },\n\n    /**\n     * Show loading spinner\n     */\n    showLoader: function(element, text = 'Loading...') {\n        const loader = document.createElement('div');\n        loader.className = 'text-center py-4 loader-overlay';\n        loader.innerHTML = `\n            <div class=\"spinner-border text-primary\" role=\"status\">\n                <span class=\"visually-hidden\">Loading...</span>\n            </div>\n            <p class=\"mt-2 text-muted\">${text}</p>\n        `;\n\n        element.style.position = 'relative';\n        element.appendChild(loader);\n        return loader;\n    },\n\n    /**\n     * Hide loading spinner\n     */\n    hideLoader: function(element) {\n        const loader = element.querySelector('.loader-overlay');\n        if (loader) {\n            loader.remove();\n        }\n    },\n\n    /**\n     * Animate counter numbers\n     */\n    animateCounter: function(element, target, duration = 2000) {\n        const start = parseInt(element.textContent) || 0;\n        const increment = (target - start) / (duration / 16);\n        let current = start;\n\n        const timer = setInterval(() => {\n            current += increment;\n            element.textContent = Math.floor(current).toLocaleString();\n\n            if ((increment > 0 && current >= target) || (increment < 0 && current <= target)) {\n                element.textContent = target.toLocaleString();\n                clearInterval(timer);\n            }\n        }, 16);\n    },\n\n    /**\n     * Smooth scroll to element\n     */\n    scrollTo: function(element, offset = 80) {\n        const elementPosition = element.offsetTop - offset;\n        window.scrollTo({\n            top: elementPosition,\n            behavior: 'smooth'\n        });\n    },\n\n    /**\n     * Check if element is in viewport\n     */\n    isInViewport: function(element) {\n        const rect = element.getBoundingClientRect();\n        return (\n            rect.top >= 0 &&\n            rect.left >= 0 &&\n            rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\n            rect.right <= (window.innerWidth || document.documentElement.clientWidth)\n        );\n    },\n\n    /**\n     * Local storage helpers\n     */\n    storage: {\n        set: function(key, value) {\n            try {\n                localStorage.setItem(`visionfit_${key}`, JSON.stringify(value));\n            } catch (e) {\n                console.error('Failed to save to localStorage:', e);\n            }\n        },\n\n        get: function(key) {\n            try {\n                const item = localStorage.getItem(`visionfit_${key}`);\n                return item ? JSON.parse(item) : null;\n            } catch (e) {\n                console.error('Failed to read from localStorage:', e);\n                return null;\n            }\n        },\n\n        remove: function(key) {\n            localStorage.removeItem(`visionfit_${key}`);\n        }\n    }\n};\n\n// API Helper Functions\nVisionFit.api = {\n    /**\n     * Generic API request handler\n     */\n    request: async function(endpoint, options = {}) {\n        const defaultOptions = {\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            credentials: 'same-origin'\n        };\n\n        const config = { ...defaultOptions, ...options };\n\n        try {\n            const response = await fetch(`${VisionFit.config.apiBase}${endpoint}`, config);\n\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n\n            const contentType = response.headers.get('content-type');\n            if (contentType && contentType.includes('application/json')) {\n                return await response.json();\n            }\n\n            return await response.text();\n        } catch (error) {\n            console.error('API request failed:', error);\n            VisionFit.utils.showToast('Network error. Please try again.', 'danger');\n            throw error;\n        }\n    },\n\n    /**\n     * GET request\n     */\n    get: function(endpoint) {\n        return this.request(endpoint, { method: 'GET' });\n    },\n\n    /**\n     * POST request\n     */\n    post: function(endpoint, data) {\n        return this.request(endpoint, {\n            method: 'POST',\n            body: JSON.stringify(data)\n        });\n    },\n\n    /**\n     * PUT request\n     */\n    put: function(endpoint, data) {\n        return this.request(endpoint, {\n            method: 'PUT',\n            body: JSON.stringify(data)\n        });\n    },\n\n    /**\n     * DELETE request\n     */\n    delete: function(endpoint) {\n        return this.request(endpoint, { method: 'DELETE' });\n    }\n};\n\n// Component: Form Validation\nVisionFit.components.formValidation = {\n    init: function() {\n        const forms = document.querySelectorAll('form[data-validate]');\n        forms.forEach(form => this.attachValidation(form));\n    },\n\n    attachValidation: function(form) {\n        const inputs = form.querySelectorAll('input, select, textarea');\n\n        inputs.forEach(input => {\n            input.addEventListener('blur', () => this.validateField(input));\n            input.addEventListener('input', () => this.clearErrors(input));\n        });\n\n        form.addEventListener('submit', (e) => {\n            if (!this.validateForm(form)) {\n                e.preventDefault();\n            }\n        });\n    },\n\n    validateField: function(field) {\n        const value = field.value.trim();\n        let isValid = true;\n        let errorMessage = '';\n\n        // Required validation\n        if (field.hasAttribute('required') && !value) {\n            isValid = false;\n            errorMessage = 'This field is required';\n        }\n\n        // Email validation\n        if (field.type === 'email' && value) {\n            const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n            if (!emailRegex.test(value)) {\n                isValid = false;\n                errorMessage = 'Please enter a valid email address';\n            }\n        }\n\n        // Password validation\n        if (field.type === 'password' && value) {\n            if (value.length < 6) {\n                isValid = false;\n                errorMessage = 'Password must be at least 6 characters';\n            }\n        }\n\n        // Custom validation patterns\n        if (field.hasAttribute('pattern') && value) {\n            const pattern = new RegExp(field.getAttribute('pattern'));\n            if (!pattern.test(value)) {\n                isValid = false;\n                errorMessage = field.getAttribute('data-error') || 'Invalid format';\n            }\n        }\n\n        this.showFieldError(field, isValid, errorMessage);\n        return isValid;\n    },\n\n    validateForm: function(form) {\n        const inputs = form.querySelectorAll('input, select, textarea');\n        let isFormValid = true;\n\n        inputs.forEach(input => {\n            if (!this.validateField(input)) {\n                isFormValid = false;\n            }\n        });\n\n        return isFormValid;\n    },\n\n    showFieldError: function(field, isValid, message) {\n        const errorElement = field.parentNode.querySelector('.error-message');\n\n        if (isValid) {\n            field.classList.remove('is-invalid');\n            if (errorElement) {\n                errorElement.remove();\n            }\n        } else {\n            field.classList.add('is-invalid');\n\n            if (!errorElement) {\n                const error = document.createElement('div');\n                error.className = 'error-message text-danger small mt-1';\n                error.textContent = message;\n                field.parentNode.appendChild(error);\n            } else {\n                errorElement.textContent = message;\n            }\n        }\n    },\n\n    clearErrors: function(field) {\n        field.classList.remove('is-invalid');\n        const errorElement = field.parentNode.querySelector('.error-message');\n        if (errorElement) {\n            errorElement.remove();\n        }\n    }\n};\n\n// Component: Smooth Animations\nVisionFit.components.animations = {\n    init: function() {\n        this.setupScrollAnimations();\n        this.setupHoverEffects();\n        this.setupParallax();\n    },\n\n    setupScrollAnimations: function() {\n        const observerOptions = {\n            threshold: 0.1,\n            rootMargin: '0px 0px -50px 0px'\n        };\n\n        const observer = new IntersectionObserver((entries) => {\n            entries.forEach(entry => {\n                if (entry.isIntersecting) {\n                    entry.target.classList.add('animate-in');\n                }\n            });\n        }, observerOptions);\n\n        // Observe elements with animation classes\n        document.querySelectorAll('.fade-in-up, .fade-in-left, .fade-in-right').forEach(el => {\n            if (el) {\n                observer.observe(el);\n            }\n        });\n    },\n\n    setupHoverEffects: function() {\n        // 3D card effects\n        document.querySelectorAll('.card-3d').forEach(card => {\n            card.addEventListener('mousemove', (e) => {\n                const rect = card.getBoundingClientRect();\n                const x = e.clientX - rect.left;\n                const y = e.clientY - rect.top;\n\n                const centerX = rect.width / 2;\n                const centerY = rect.height / 2;\n\n                const rotateX = (y - centerY) / 10;\n                const rotateY = (centerX - x) / 10;\n\n                card.style.transform = `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) translateZ(10px)`;\n            });\n\n            card.addEventListener('mouseleave', () => {\n                card.style.transform = 'perspective(1000px) rotateX(0deg) rotateY(0deg) translateZ(0px)';\n            });\n        });\n    },\n\n    setupParallax: function() {\n        const parallaxElements = document.querySelectorAll('.parallax-element');\n\n        if (parallaxElements.length === 0) return;\n\n        const handleScroll = VisionFit.utils.debounce(() => {\n            const scrolled = window.pageYOffset;\n\n            parallaxElements.forEach(element => {\n                const rate = scrolled * -0.5;\n                element.style.transform = `translateY(${rate}px)`;\n            });\n        }, 10);\n\n        window.addEventListener('scroll', handleScroll);\n    }\n};\n\n// Component: Timer\nVisionFit.components.timer = {\n    timers: new Map(),\n\n    start: function(id, callback, interval = 1000) {\n        if (this.timers.has(id)) {\n            this.stop(id);\n        }\n\n        const startTime = Date.now();\n        const timer = setInterval(() => {\n            const elapsed = Date.now() - startTime;\n            callback(Math.floor(elapsed / 1000));\n        }, interval);\n\n        this.timers.set(id, { timer, startTime });\n    },\n\n    stop: function(id) {\n        const timerData = this.timers.get(id);\n        if (timerData) {\n            clearInterval(timerData.timer);\n            this.timers.delete(id);\n        }\n    },\n\n    getElapsed: function(id) {\n        const timerData = this.timers.get(id);\n        if (timerData) {\n            return Math.floor((Date.now() - timerData.startTime) / 1000);\n        }\n        return 0;\n    },\n\n    formatTime: function(seconds) {\n        const mins = Math.floor(seconds / 60);\n        const secs = seconds % 60;\n        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n    }\n};\n\n// Component: Camera Helper\nVisionFit.components.camera = {\n    stream: null,\n    isActive: false,\n\n    async initialize(videoElement, constraints = {}) {\n        // Check if browser supports getUserMedia\n        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n            const errorMsg = 'Your browser does not support camera access. Please try a modern browser like Chrome, Firefox, or Edge.';\n            console.error(errorMsg);\n            VisionFit.utils.showToast(errorMsg, 'danger');\n            throw new Error(errorMsg);\n        }\n\n        const defaultConstraints = {\n            video: {\n                width: { ideal: 1280 },\n                height: { ideal: 720 },\n                facingMode: 'user'\n            },\n            audio: false\n        };\n\n        const finalConstraints = { ...defaultConstraints, ...constraints };\n        console.log('Camera constraints:', finalConstraints);\n\n        try {\n            console.log('Attempting to access camera...');\n            this.stream = await navigator.mediaDevices.getUserMedia(finalConstraints);\n            console.log('Camera access granted:', this.stream);\n\n            // Ensure video element exists\n            if (!videoElement) {\n                throw new Error('Video element not found');\n            }\n\n            videoElement.srcObject = this.stream;\n            this.isActive = true;\n\n            return new Promise((resolve) => {\n                videoElement.onloadedmetadata = () => {\n                    console.log('Video metadata loaded');\n\n                    // Fix video orientation and display\n                    videoElement.style.transform = 'scaleX(-1)'; // Mirror the video\n                    videoElement.style.width = '100%';\n                    videoElement.style.height = 'auto';\n                    videoElement.style.objectFit = 'cover';\n\n                    // Ensure video is visible\n                    videoElement.style.display = 'block';\n\n                    resolve(this.stream);\n                };\n\n                // Add a fallback in case onloadedmetadata doesn't fire\n                setTimeout(() => {\n                    if (this.isActive && this.stream) {\n                        console.log('Video metadata timeout - resolving anyway');\n\n                        // Apply orientation fixes even if metadata didn't load\n                        videoElement.style.transform = 'scaleX(-1)';\n                        videoElement.style.width = '100%';\n                        videoElement.style.height = 'auto';\n                        videoElement.style.objectFit = 'cover';\n                        videoElement.style.display = 'block';\n\n                        resolve(this.stream);\n                    }\n                }, 1000);\n            });\n        } catch (error) {\n            console.error('Camera initialization failed:', error.name, error.message);\n            let errorMsg = 'Failed to access camera. ';\n\n            // Provide more specific error messages\n            if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\n                errorMsg += 'Please allow camera access in your browser permissions.';\n            } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\n                errorMsg += 'No camera detected. Please connect a camera and try again.';\n            } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {\n                errorMsg += 'Camera is in use by another application. Please close other apps using the camera.';\n            } else if (error.name === 'OverconstrainedError') {\n                errorMsg += 'Camera constraints cannot be satisfied. Using default settings.';\n                // Try again with minimal constraints\n                return this.initialize(videoElement, { video: true, audio: false });\n            } else {\n                errorMsg += error.message || 'Unknown camera error.';\n            }\n\n            VisionFit.utils.showToast(errorMsg, 'danger');\n            throw error;\n        }\n    },\n\n    stop() {\n        console.log('Stopping camera...');\n        if (this.stream) {\n            try {\n                const tracks = this.stream.getTracks();\n                console.log(`Stopping ${tracks.length} camera tracks`);\n                tracks.forEach(track => {\n                    try {\n                        track.stop();\n                        console.log(`Track ${track.id} stopped successfully`);\n                    } catch (trackError) {\n                        console.error(`Error stopping track ${track.id}:`, trackError);\n                    }\n                });\n            } catch (streamError) {\n                console.error('Error accessing stream tracks:', streamError);\n            } finally {\n                this.stream = null;\n                this.isActive = false;\n                console.log('Camera stopped and resources cleared');\n            }\n        } else {\n            console.log('No active camera stream to stop');\n            this.isActive = false;\n        }\n    },\n\n    captureFrame(videoElement, canvasElement) {\n        if (!this.isActive) return null;\n\n        const context = canvasElement.getContext('2d');\n        canvasElement.width = videoElement.videoWidth;\n        canvasElement.height = videoElement.videoHeight;\n\n        context.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);\n\n        return {\n            canvas: canvasElement,\n            dataURL: canvasElement.toDataURL('image/jpeg', 0.8),\n            imageData: context.getImageData(0, 0, canvasElement.width, canvasElement.height)\n        };\n    }\n};\n\n// Initialize app when DOM is ready\ndocument.addEventListener('DOMContentLoaded', function() {\n    // Initialize components\n    VisionFit.components.formValidation.init();\n    VisionFit.components.animations.init();\n\n    // Setup global event listeners\n    setupGlobalEventListeners();\n\n    // Setup navigation enhancements\n    setupNavigation();\n\n    // Setup responsive handling\n    setupResponsiveHandlers();\n\n    console.log('VisionFit AI initialized successfully');\n});\n\n// Global event listeners\nfunction setupGlobalEventListeners() {\n    // Handle all form submissions with loading states\n    document.addEventListener('submit', function(e) {\n        const form = e.target;\n        const submitBtn = form.querySelector('button[type=\"submit\"]');\n\n        if (submitBtn && !submitBtn.disabled) {\n            const originalText = submitBtn.innerHTML;\n            submitBtn.innerHTML = '<i class=\"fas fa-spinner fa-spin me-2\"></i>Loading...';\n            submitBtn.disabled = true;\n\n            // Re-enable after 5 seconds as fallback\n            setTimeout(() => {\n                submitBtn.innerHTML = originalText;\n                submitBtn.disabled = false;\n            }, 5000);\n        }\n    });\n\n    // Handle flash message auto-hide\n    setTimeout(() => {\n        const alerts = document.querySelectorAll('.alert-dismissible');\n        alerts.forEach(alert => {\n            if (alert.querySelector('.btn-close')) {\n                alert.querySelector('.btn-close').click();\n            }\n        });\n    }, 5000);\n\n    // Handle smooth scrolling for anchor links\n    document.addEventListener('click', function(e) {\n        const link = e.target.closest('a[href^=\"#\"]');\n        if (link) {\n            e.preventDefault();\n            const targetId = link.getAttribute('href').substring(1);\n            const targetElement = document.getElementById(targetId);\n\n            if (targetElement) {\n                VisionFit.utils.scrollTo(targetElement);\n            }\n        }\n    });\n}\n\n// Navigation enhancements\nfunction setupNavigation() {\n    const navbar = document.querySelector('.navbar');\n    if (!navbar) return;\n\n    // Navbar scroll effect\n    let lastScrollY = window.scrollY;\n\n    window.addEventListener('scroll', VisionFit.utils.debounce(() => {\n        const currentScrollY = window.scrollY;\n\n        if (currentScrollY > 100) {\n            navbar.classList.add('scrolled');\n        } else {\n            navbar.classList.remove('scrolled');\n        }\n\n        // Hide/show navbar on scroll\n        if (currentScrollY > lastScrollY && currentScrollY > 200) {\n            navbar.style.transform = 'translateY(-100%)';\n        } else {\n            navbar.style.transform = 'translateY(0)';\n        }\n\n        lastScrollY = currentScrollY;\n    }, 100));\n\n    // Active nav item highlighting\n    const navLinks = navbar.querySelectorAll('.nav-link');\n    const currentPath = window.location.pathname;\n\n    navLinks.forEach(link => {\n        if (link.getAttribute('href') === currentPath) {\n            link.classList.add('active');\n        }\n    });\n}\n\n// Responsive handlers\nfunction setupResponsiveHandlers() {\n    // Handle mobile menu\n    const navbarToggler = document.querySelector('.navbar-toggler');\n    const navbarCollapse = document.querySelector('.navbar-collapse');\n\n    if (navbarToggler && navbarCollapse) {\n        document.addEventListener('click', function(e) {\n            if (!navbarCollapse.contains(e.target) && !navbarToggler.contains(e.target)) {\n                const bsCollapse = bootstrap.Collapse.getInstance(navbarCollapse);\n                if (bsCollapse && navbarCollapse.classList.contains('show')) {\n                    bsCollapse.hide();\n                }\n            }\n        });\n    }\n\n    // Handle window resize\n    window.addEventListener('resize', VisionFit.utils.debounce(() => {\n        // Recalculate any layout-dependent components\n        const event = new CustomEvent('visionfit:resize');\n        window.dispatchEvent(event);\n    }, 250));\n}\n\n// Export for global access\nwindow.VisionFit = VisionFit;\n","size_bytes":23346},"static/js/pose-detection.js":{"content":"// VisionFit AI - MediaPipe Pose Detection Implementation\n\nclass PoseDetector {\n    constructor() {\n        this.pose = null;\n        this.camera = null;\n        this.video = null;\n        this.canvas = null;\n        this.ctx = null;\n        this.isActive = false;\n        this.exerciseType = 'pushup';\n        this.exerciseCounters = {\n            pushup: new PushupCounter(),\n            squat: new SquatCounter(),\n            jumping_jack: new JumpingJackCounter()\n        };\n    }\n\n    async initialize() {\n        try {\n            // Initialize MediaPipe Pose\n            this.pose = new Pose({\n                locateFile: (file) => {\n                    return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;\n                }\n            });\n\n            this.pose.setOptions({\n                modelComplexity: 1,\n                smoothLandmarks: true,\n                enableSegmentation: false,\n                smoothSegmentation: false,\n                minDetectionConfidence: 0.5,\n                minTrackingConfidence: 0.5\n            });\n\n            this.pose.onResults(this.onResults.bind(this));\n\n            // Get video and canvas elements\n            this.video = document.getElementById('video');\n            this.canvas = document.getElementById('canvas');\n            this.ctx = this.canvas.getContext('2d');\n\n            console.log('Pose detector initialized successfully');\n            return true;\n        } catch (error) {\n            console.error('Failed to initialize pose detector:', error);\n            return false;\n        }\n    }\n\n    async start() {\n        try {\n            if (!this.pose) {\n                const initialized = await this.initialize();\n                if (!initialized) {\n                    throw new Error('Failed to initialize pose detector');\n                }\n            }\n\n            // Get camera stream\n            const stream = await navigator.mediaDevices.getUserMedia({\n                video: {\n                    width: { ideal: 1280 },\n                    height: { ideal: 720 },\n                    facingMode: 'user'\n                }\n            });\n\n            this.video.srcObject = stream;\n            this.video.play();\n\n            // Wait for video to load\n            await new Promise((resolve) => {\n                this.video.onloadedmetadata = () => {\n                    this.canvas.width = this.video.videoWidth;\n                    this.canvas.height = this.video.videoHeight;\n                    resolve();\n                };\n            });\n\n            // Initialize camera\n            this.camera = new Camera(this.video, {\n                onFrame: async () => {\n                    if (this.isActive) {\n                        await this.pose.send({ image: this.video });\n                    }\n                },\n                width: 1280,\n                height: 720\n            });\n\n            await this.camera.start();\n            this.isActive = true;\n\n            console.log('Camera started successfully');\n        } catch (error) {\n            console.error('Failed to start camera:', error);\n            throw error;\n        }\n    }\n\n    stop() {\n        if (this.camera) {\n            this.camera.stop();\n        }\n\n        if (this.video && this.video.srcObject) {\n            const tracks = this.video.srcObject.getTracks();\n            tracks.forEach(track => track.stop());\n            this.video.srcObject = null;\n        }\n\n        this.isActive = false;\n        console.log('Camera stopped');\n    }\n\n    setExerciseType(exerciseType) {\n        this.exerciseType = exerciseType;\n        this.reset();\n    }\n\n    reset() {\n        Object.values(this.exerciseCounters).forEach(counter => {\n            if (counter.reset) {\n                counter.reset();\n            }\n        });\n    }\n\n    onResults(results) {\n        if (!this.ctx || !this.canvas) return;\n\n        // Clear canvas\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n        // Draw the pose landmarks\n        if (results.poseLandmarks) {\n            this.drawPose(results.poseLandmarks);\n\n            // Analyze exercise\n            const counter = this.exerciseCounters[this.exerciseType];\n            if (counter) {\n                const analysis = counter.analyze(results.poseLandmarks);\n                this.updateUI(analysis);\n            }\n        }\n    }\n\n    drawPose(landmarks) {\n        // Draw pose connections\n        this.drawConnections(landmarks);\n\n        // Draw landmarks\n        this.drawLandmarks(landmarks);\n    }\n\n    drawConnections(landmarks) {\n        const connections = [\n            // Face\n            [0, 1], [1, 2], [2, 3], [3, 7],\n            [0, 4], [4, 5], [5, 6], [6, 8],\n            // Body\n            [9, 10],\n            [11, 12], [11, 13], [13, 15], [15, 17], [15, 19], [15, 21],\n            [12, 14], [14, 16], [16, 18], [16, 20], [16, 22],\n            [11, 23], [12, 24], [23, 24],\n            // Legs\n            [23, 25], [25, 27], [27, 29], [27, 31],\n            [24, 26], [26, 28], [28, 30], [28, 32]\n        ];\n\n        this.ctx.strokeStyle = '#A855F7';\n        this.ctx.lineWidth = 3;\n\n        connections.forEach(([startIdx, endIdx]) => {\n            const start = landmarks[startIdx];\n            const end = landmarks[endIdx];\n\n            if (start && end && start.visibility > 0.5 && end.visibility > 0.5) {\n                this.ctx.beginPath();\n                this.ctx.moveTo(start.x * this.canvas.width, start.y * this.canvas.height);\n                this.ctx.lineTo(end.x * this.canvas.width, end.y * this.canvas.height);\n                this.ctx.stroke();\n            }\n        });\n    }\n\n    drawLandmarks(landmarks) {\n        landmarks.forEach((landmark, index) => {\n            if (landmark.visibility > 0.5) {\n                const x = landmark.x * this.canvas.width;\n                const y = landmark.y * this.canvas.height;\n\n                // Key landmarks in different colors\n                if ([11, 12, 13, 14, 15, 16].includes(index)) {\n                    // Arms - primary color\n                    this.ctx.fillStyle = '#A855F7';\n                } else if ([23, 24, 25, 26, 27, 28].includes(index)) {\n                    // Legs - accent color\n                    this.ctx.fillStyle = '#34D399';\n                } else {\n                    // Other landmarks - white\n                    this.ctx.fillStyle = '#FFFFFF';\n                }\n\n                this.ctx.beginPath();\n                this.ctx.arc(x, y, 5, 0, 2 * Math.PI);\n                this.ctx.fill();\n            }\n        });\n    }\n\n    updateUI(analysis) {\n        // Update rep count\n        if (analysis.reps !== undefined && window.exerciseTrackerCallbacks) {\n            window.exerciseTrackerCallbacks.updateRepCount(analysis.reps);\n        }\n\n        // Update form score\n        if (analysis.form_score !== undefined && window.exerciseTrackerCallbacks) {\n            window.exerciseTrackerCallbacks.updateFormScore(analysis.form_score);\n        }\n\n        // Update feedback\n        if (analysis.feedback && window.exerciseTrackerCallbacks) {\n            window.exerciseTrackerCallbacks.updateLiveFeedback(analysis.feedback);\n        }\n    }\n}\n\n// Exercise-specific counters\nclass PushupCounter {\n    constructor() {\n        this.state = \"up\";\n        this.repCount = 0;\n        this.lastAngle = 180;\n    }\n\n    reset() {\n        this.state = \"up\";\n        this.repCount = 0;\n        this.lastAngle = 180;\n    }\n\n    analyze(landmarks) {\n        try {\n            if (!landmarks || landmarks.length < 33) {\n                return { error: \"Insufficient landmarks detected\" };\n            }\n\n            // Get key points\n            const leftShoulder = landmarks[11];\n            const rightShoulder = landmarks[12];\n            const leftElbow = landmarks[13];\n            const rightElbow = landmarks[14];\n            const leftWrist = landmarks[15];\n            const rightWrist = landmarks[16];\n            const leftHip = landmarks[23];\n            const rightHip = landmarks[24];\n\n            // Calculate arm angles\n            const leftArmAngle = this.calculateAngle(\n                [leftShoulder.x, leftShoulder.y],\n                [leftElbow.x, leftElbow.y],\n                [leftWrist.x, leftWrist.y]\n            );\n\n            const rightArmAngle = this.calculateAngle(\n                [rightShoulder.x, rightShoulder.y],\n                [rightElbow.x, rightElbow.y],\n                [rightWrist.x, rightWrist.y]\n            );\n\n            const avgArmAngle = (leftArmAngle + rightArmAngle) / 2;\n\n            // Body alignment\n            const bodyAlignment = this.calculateBodyAlignment(\n                leftShoulder, rightShoulder, leftHip, rightHip\n            );\n\n            // Count reps\n            if (this.state === \"up\" && avgArmAngle < 90) {\n                this.state = \"down\";\n            } else if (this.state === \"down\" && avgArmAngle > 160) {\n                this.state = \"up\";\n                this.repCount++;\n            }\n\n            // Form score\n            const formScore = this.calculateFormScore(avgArmAngle, bodyAlignment);\n\n            // Feedback\n            const feedback = this.generateFeedback(avgArmAngle, bodyAlignment);\n\n            return {\n                reps: this.repCount,\n                form_score: Math.round(formScore * 10) / 10,\n                feedback: feedback,\n                arm_angle: Math.round(avgArmAngle),\n                body_alignment: Math.round(bodyAlignment)\n            };\n\n        } catch (error) {\n            console.error('Error in pushup analysis:', error);\n            return { error: \"Analysis failed\" };\n        }\n    }\n\n    calculateAngle(a, b, c) {\n        const radians = Math.atan2(c[1] - b[1], c[0] - b[0]) - Math.atan2(a[1] - b[1], a[0] - b[0]);\n        let angle = Math.abs(radians * 180.0 / Math.PI);\n        if (angle > 180.0) {\n            angle = 360 - angle;\n        }\n        return angle;\n    }\n\n    calculateBodyAlignment(leftShoulder, rightShoulder, leftHip, rightHip) {\n        const shoulderCenter = [\n            (leftShoulder.x + rightShoulder.x) / 2,\n            (leftShoulder.y + rightShoulder.y) / 2\n        ];\n        const hipCenter = [\n            (leftHip.x + rightHip.x) / 2,\n            (leftHip.y + rightHip.y) / 2\n        ];\n\n        const verticalDeviation = Math.abs(shoulderCenter[1] - hipCenter[1]);\n        return Math.max(0, 100 - (verticalDeviation * 1000));\n    }\n\n    calculateFormScore(armAngle, bodyAlignment) {\n        let angleScore;\n        if ((armAngle >= 60 && armAngle <= 90) || (armAngle >= 160 && armAngle <= 180)) {\n            angleScore = 100;\n        } else {\n            angleScore = Math.max(0, 100 - Math.abs(armAngle - 90) * 2);\n        }\n\n        return (angleScore * 0.7) + (bodyAlignment * 0.3);\n    }\n\n    generateFeedback(armAngle, bodyAlignment) {\n        const feedback = [];\n\n        if (armAngle < 60) {\n            feedback.push(\"Go deeper - lower your chest more\");\n        } else if (armAngle > 120 && armAngle < 160) {\n            feedback.push(\"Push all the way up\");\n        }\n\n        if (bodyAlignment < 70) {\n            feedback.push(\"Keep your body straight\");\n        }\n\n        if (feedback.length === 0) {\n            feedback.push(\"Great form! Keep it up!\");\n        }\n\n        return feedback;\n    }\n}\n\nclass SquatCounter {\n    constructor() {\n        this.state = \"up\";\n        this.repCount = 0;\n    }\n\n    reset() {\n        this.state = \"up\";\n        this.repCount = 0;\n    }\n\n    analyze(landmarks) {\n        try {\n            if (!landmarks || landmarks.length < 33) {\n                return { error: \"Insufficient landmarks detected\" };\n            }\n\n            const leftHip = landmarks[23];\n            const rightHip = landmarks[24];\n            const leftKnee = landmarks[25];\n            const rightKnee = landmarks[26];\n            const leftAnkle = landmarks[27];\n            const rightAnkle = landmarks[28];\n\n            // Calculate knee angles\n            const leftKneeAngle = this.calculateAngle(\n                [leftHip.x, leftHip.y],\n                [leftKnee.x, leftKnee.y],\n                [leftAnkle.x, leftAnkle.y]\n            );\n\n            const rightKneeAngle = this.calculateAngle(\n                [rightHip.x, rightHip.y],\n                [rightKnee.x, rightKnee.y],\n                [rightAnkle.x, rightAnkle.y]\n            );\n\n            const avgKneeAngle = (leftKneeAngle + rightKneeAngle) / 2;\n\n            // Count reps\n            if (this.state === \"up\" && avgKneeAngle < 120) {\n                this.state = \"down\";\n            } else if (this.state === \"down\" && avgKneeAngle > 160) {\n                this.state = \"up\";\n                this.repCount++;\n            }\n\n            // Form score\n            const formScore = this.calculateFormScore(avgKneeAngle);\n\n            // Feedback\n            const feedback = this.generateFeedback(avgKneeAngle);\n\n            return {\n                reps: this.repCount,\n                form_score: Math.round(formScore * 10) / 10,\n                feedback: feedback,\n                knee_angle: Math.round(avgKneeAngle)\n            };\n\n        } catch (error) {\n            console.error('Error in squat analysis:', error);\n            return { error: \"Analysis failed\" };\n        }\n    }\n\n    calculateAngle(a, b, c) {\n        const radians = Math.atan2(c[1] - b[1], c[0] - b[0]) - Math.atan2(a[1] - b[1], a[0] - b[0]);\n        let angle = Math.abs(radians * 180.0 / Math.PI);\n        if (angle > 180.0) {\n            angle = 360 - angle;\n        }\n        return angle;\n    }\n\n    calculateFormScore(kneeAngle) {\n        if (kneeAngle >= 90 && kneeAngle <= 120) {\n            return 100;\n        } else {\n            return Math.max(0, 100 - Math.abs(kneeAngle - 105) * 2);\n        }\n    }\n\n    generateFeedback(kneeAngle) {\n        const feedback = [];\n\n        if (kneeAngle > 140) {\n            feedback.push(\"Go deeper - squat down more\");\n        } else if (kneeAngle < 80) {\n            feedback.push(\"Don't go too low\");\n        }\n\n        if (feedback.length === 0) {\n            feedback.push(\"Perfect squat form!\");\n        }\n\n        return feedback;\n    }\n}\n\nclass JumpingJackCounter {\n    constructor() {\n        this.state = \"closed\";\n        this.repCount = 0;\n    }\n\n    reset() {\n        this.state = \"closed\";\n        this.repCount = 0;\n    }\n\n    analyze(landmarks) {\n        try {\n            if (!landmarks || landmarks.length < 33) {\n                return { error: \"Insufficient landmarks detected\" };\n            }\n\n            const leftWrist = landmarks[15];\n            const rightWrist = landmarks[16];\n            const leftAnkle = landmarks[27];\n            const rightAnkle = landmarks[28];\n            const nose = landmarks[0];\n\n            // Calculate spreads\n            const armSpread = Math.abs(leftWrist.x - rightWrist.x);\n            const legSpread = Math.abs(leftAnkle.x - rightAnkle.x);\n\n            // Normalize by body height\n            const bodyHeight = Math.abs(nose.y - Math.min(leftAnkle.y, rightAnkle.y));\n            const armRatio = bodyHeight > 0 ? armSpread / bodyHeight : 0;\n            const legRatio = bodyHeight > 0 ? legSpread / bodyHeight : 0;\n\n            // Determine position\n            const isOpen = armRatio > 0.3 && legRatio > 0.2;\n\n            // Count reps\n            if (this.state === \"closed\" && isOpen) {\n                this.state = \"open\";\n            } else if (this.state === \"open\" && !isOpen) {\n                this.state = \"closed\";\n                this.repCount++;\n            }\n\n            // Form score\n            const formScore = this.calculateFormScore(armRatio, legRatio);\n\n            // Feedback\n            const feedback = this.generateFeedback(armRatio, legRatio);\n\n            return {\n                reps: this.repCount,\n                form_score: Math.round(formScore * 10) / 10,\n                feedback: feedback,\n                position: isOpen ? \"open\" : \"closed\"\n            };\n\n        } catch (error) {\n            console.error('Error in jumping jack analysis:', error);\n            return { error: \"Analysis failed\" };\n        }\n    }\n\n    calculateFormScore(armRatio, legRatio) {\n        const coordinationScore = 100 - Math.abs(armRatio - legRatio) * 200;\n        return Math.max(0, Math.min(100, coordinationScore));\n    }\n\n    generateFeedback(armRatio, legRatio) {\n        const feedback = [];\n\n        if (armRatio < 0.2) {\n            feedback.push(\"Raise your arms higher\");\n        }\n        if (legRatio < 0.15) {\n            feedback.push(\"Jump with wider legs\");\n        }\n\n        if (feedback.length === 0) {\n            feedback.push(\"Great jumping jacks!\");\n        }\n\n        return feedback;\n    }\n}\n\n// Initialize pose detection\nfunction initializePoseDetection() {\n    window.poseDetector = new PoseDetector();\n    console.log('Pose detection system initialized');\n}\n\n// Export for global use\nwindow.PoseDetector = PoseDetector;\nwindow.initializePoseDetection = initializePoseDetection;\n","size_bytes":17042}},"version":1}